üì• INSERT: Inserci√≥n de Datos en PostgreSQL

El comando INSERT es fundamental para agregar nuevos registros a tus tablas. Vamos a explorarlo en profundidad, desde lo b√°sico hasta t√©cnicas avanzadas.
√çNDICE

    Sintaxis B√°sica

    Tipos de Inserci√≥n

    Valores por Defecto

    Inserci√≥n M√∫ltiple

    INSERTAR con SELECCIONAR

    INSERTAR con RETORNO

    UPSERT (INSERTAR SOBRE CONFLICTO)

    Inserci√≥n desde Archivos

    Buenas Pr√°cticas

    Ejemplos con Python 

1. SINTAXIS B√ÅSICA
Forma Est√°ndar
SQL

-- Sintaxis b√°sica 
INSERT  INTO  nombre_tabla  ( columna1 ,  columna2 ,  . . . ) 
VALUES  ( valor1 ,  valor2 ,  . . . ) ; 

-- Ejemplo concreto 
INSERT  INTO  clientes  ( nombre ,  email ,  telefono ,  fecha_registro ) 
VALUES  ( 'Juan P√©rez' ,  'juan@email.com' ,  '+34 600 123 456' ,  '2024-01-15' ) ; 

Inserci√≥n Simplificada (cuando insertas en todas las columnas)
SQL

-- Si insertas valores para TODAS las columnas, en orden 
INSERT  INTO  productos  VALUES  
( 1 ,  'Laptop Dell' ,  999.99 ,  10 ,  'Electr√≥nica' ,  CURRENT_TIMESTAMP ) ; 

-- ‚ö†Ô∏è PELIGROSO: Si la estructura de la tabla cambia, esto fallar√° 

Especificando Columnas Expl√≠citamente (RECOMENDADO)
SQL

-- Forma segura y expl√≠cita 
INSERT  INTO  empleados  ( 
    nombre ,  
    apellido ,  
    email ,  
    salario ,  
    departamento_id , 
    fecha_contratacion
 )  VALUES  ( 
    'Mar√≠a' ,  
    'Garc√≠a' ,  
    'maria@empresa.com' ,  
    45000.00 ,  
    3 , 
    '2024-01-20' 
) ; 

2. TIPOS DE INSERCI√ìN
Inserci√≥n con Valores Literales
SQL

-- Valores directos 
INSERT  INTO  productos  ( 
    nombre ,  
    descripcion ,  
    precio ,  
    stock , 
    categoria
 )  VALUES  ( 
    'Mouse Gaming' ,  
    'Mouse RGB con 6 botones programables' ,  
    49.99 ,  
    100 , 
    'Perif√©ricos' 
) ; 

Inserci√≥n con Expresiones
SQL

-- Usando funciones y expresiones 
INSERT  INTO  logs  ( 
    nivel , 
    mensaje , 
    fecha_hora , 
    usuario_id , 
    ip_address
 )  VALUES  ( 
    'INFO' , 
    'Usuario autenticado correctamente' , 
    CURRENT_TIMESTAMP ,   -- Funci√≥n de fecha/hora actual 
    ( SELECT  id  FROM  usuarios  WHERE  username  =  'admin' ) ,   -- Subconsulta 
    INET  '192.168.1.100'   -- Tipo de dato espec√≠fico 
) ; 

Inserci√≥n con Tipos de Datos Especiales
SQL

-- JSON/JSONB 
INSERT  INTO  configuraciones  ( 
    usuario_id , 
    preferencias
 )  VALUES  ( 
    1 , 
    '{"tema": "oscuro", "notificaciones": true, "idioma": "es"}' ::jsonb
 ) ; 

-- Arrays 
INSERT  INTO  cursos  ( 
    nombre , 
    estudiantes , 
    habilidades
 )  VALUES  ( 
    'Programaci√≥n Python' , 
    ARRAY [ 'Juan' ,  'Mar√≠a' ,  'Carlos' ] ,   -- Array de texto 
    ARRAY [ 1 ,  2 ,  3 ,  4 ,  5 ] :: integer [ ]      -- Array de enteros 
) ; 

-- UUID 
INSERT  INTO  transacciones  ( 
    id ,   -- Tipo UUID 
    monto , 
    descripcion
 )  VALUES  ( 
    gen_random_uuid ( ) ,   -- Genera UUID aleatorio 
    150.75 , 
    'Compra en l√≠nea' 
) ; 

-- Datos Geogr√°ficos (PostGIS) 
INSERT  INTO  ubicaciones  ( 
    nombre , 
    coordenadas
 )  VALUES  ( 
    'Oficina Central' , 
    ST_GeomFromText ( 'POINT(-3.703790 40.416775)' )   -- Madrid 
) ; 

3. VALORES POR DEFECTO
Columnas con DEFAULT
SQL

-- Tabla con valores por defecto 
CREATE  TABLE  pedidos  ( 
    id  SERIAL  PRIMARY  KEY , 
    numero_pedido  VARCHAR ( 20 )  UNIQUE  NOT  NULL , 
    cliente_id  INT  NOT  NULL , 
    total  DECIMAL ( 10 ,  2 )  NOT  NULL , 
    estado  VARCHAR ( 20 )  DEFAULT  'pendiente' , 
    fecha_pedido  TIMESTAMP  DEFAULT  CURRENT_TIMESTAMP , 
    fecha_entrega  DATE , 
    notas  TEXT 
) ; 

-- Inserci√≥n usando DEFAULT 
INSERT  INTO  pedidos  ( numero_pedido ,  cliente_id ,  total )  
VALUES  ( 'PED-001' ,  1 ,  199.99 ) ; 
-- estado = 'pendiente', fecha_pedido = ahora() 

-- Inserci√≥n expl√≠cita con DEFAULT 
INSERT  INTO  pedidos  ( 
    numero_pedido , 
    cliente_id , 
    total , 
    estado , 
    fecha_pedido
 )  VALUES  ( 
    'PED-002' , 
    2 , 
    299.99 , 
    DEFAULT ,       -- Usa el valor por defecto de la columna 
    DEFAULT        -- Usa CURRENT_TIMESTAMP 
) ; 

-- Inserci√≥n usando NULL (si la columna permite NULL) 
INSERT  INTO  pedidos  ( 
    numero_pedido , 
    cliente_id , 
    total , 
    fecha_entrega
 )  VALUES  ( 
    'PED-003' , 
    3 , 
    150.00 , 
    NULL   -- Expl√≠citamente NULL 
) ; 

Columnas SERIAL/AUTO_INCREMENT
SQL

CREATE  TABLE  usuarios  ( 
    id  SERIAL  PRIMARY  KEY ,            -- Auto-incremental 
    username  VARCHAR ( 50 )  UNIQUE  NOT  NULL , 
    email  VARCHAR ( 100 )  UNIQUE  NOT  NULL 
) ; 

-- PostgreSQL genera autom√°ticamente el ID 
INSERT  INTO  usuarios  ( username ,  email )  
VALUES  ( 'jperez' ,  'juan@email.com' ) ; 
-- id = 1 (generado autom√°ticamente) 

INSERT  INTO  usuarios  ( username ,  email )  
VALUES  ( 'mgarcia' ,  'maria@email.com' ) ; 
-- id = 2 

-- Tambi√©n puedes especificar el ID manualmente 
INSERT  INTO  usuarios  ( id ,  username ,  email )  
VALUES  ( 100 ,  'admin' ,  'admin@email.com' ) ; 
-- Ahora los siguientes ser√°n 101, 102, etc. 

4. INSERCI√ìN M√öLTIPLE
Inserci√≥n de M√∫ltiples Filas en una Sentencia
SQL

-- Insertar varias filas a la vez (MUY EFICIENTE) 
INSERT  INTO  productos  ( nombre ,  precio ,  categoria ,  stock )  VALUES 
( 'Laptop Dell' ,  899.99 ,  'Electr√≥nica' ,  15 ) , 
( 'Mouse Logitech' ,  29.99 ,  'Perif√©ricos' ,  50 ) , 
( 'Teclado Mec√°nico' ,  89.99 ,  'Perif√©ricos' ,  30 ) , 
( 'Monitor 24"' ,  199.99 ,  'Electr√≥nica' ,  20 ) , 
( 'Auriculares' ,  59.99 ,  'Audio' ,  40 ) ; 

-- L√≠mite pr√°ctico: PostgreSQL no tiene l√≠mite estricto, pero 
-- por rendimiento, es mejor insertar en lotes de 100-1000 filas 

-- Inserci√≥n masiva con arrays (alternativa) 
INSERT  INTO  estudiantes  ( nombre ,  edad ,  curso ) 
SELECT  unnest ( ARRAY [ 'Ana' ,  'Luis' ,  'Carlos' ] ) , 
       unnest ( ARRAY [ 20 ,  22 ,  21 ] ) , 
       unnest ( ARRAY [ 'Matem√°ticas' ,  'F√≠sica' ,  'Qu√≠mica' ] ) ; 

Comparaci√≥n de Rendimiento
SQL

-- ‚ùå INEFICIENTE: Muchas inserciones individuales 
INSERT  INTO  logs  ( mensaje )  VALUES  ( 'Log 1' ) ; 
INSERT  INTO  logs  ( mensaje )  VALUES  ( 'Log 2' ) ; 
INSERT  INTO  logs  ( mensaje )  VALUES  ( 'Log 3' ) ; 
-- ... (1000 veces) 

-- ‚úÖ EFICIENTE: Una sola inserci√≥n m√∫ltiple 
INSERT  INTO  logs  ( mensaje )  VALUES 
( 'Log 1' ) ,  ( 'Log 2' ) ,  ( 'Log 3' ) ,  . . .  ( 'Log 1000' ) ; 

-- ‚è±Ô∏è La inserci√≥n m√∫ltiple puede ser 10-100x m√°s r√°pida 

5. INSERTAR CON SELECT
Copiar Datos de Otra Tabla
SQL

-- Copiar todos los datos 
INSERT  INTO  clientes_archivo
 SELECT  *  FROM  clientes 
 WHERE  fecha_registro  <  '2020-01-01' ; 

-- Copiar con transformaci√≥n 
INSERT  INTO  reporte_ventas  ( mes ,  total_ventas ,  num_pedidos ) 
SELECT  
    DATE_TRUNC ( 'month' ,  fecha )  AS  mes , 
    SUM ( total )  AS  total_ventas , 
    COUNT ( * )  AS  num_pedidos
 FROM  pedidos
 WHERE  fecha  BETWEEN  '2024-01-01'  AND  '2024-12-31' 
GROUP  BY  DATE_TRUNC ( 'month' ,  fecha ) ; 

-- Copiar con JOINs 
INSERT  INTO  pedidos_detallados  ( 
    pedido_id , 
    cliente_nombre , 
    producto_nombre , 
    cantidad , 
    precio_unitario
 ) 
SELECT  
    p . id , 
    c . nombre , 
    pr . nombre , 
    dp . cantidad , 
    dp . precio_unitario
 FROM  pedidos p
 JOIN  clientes c  ON  p . cliente_id  =  c . id
 JOIN  detalles_pedido dp  ON  p . id  =  dp . pedido_id
 JOIN  productos pr  ON  dp . producto_id  =  pr . id
 WHERE  p . fecha  >=  '2024-01-01' ; 

-- Crear tabla temporal con datos 
INSERT  INTO  temp_top_clientes
 SELECT  
    c . id , 
    c . nombre , 
    COUNT ( p . id )  as  total_pedidos , 
    SUM ( p . total )  as  total_gastado
 FROM  clientes c
 LEFT  JOIN  pedidos p  ON  c . id  =  p . cliente_id
 GROUP  BY c  .  id  ,  c  .  nombre
 TENER   SUMA  (  p  .  total  )   >   1000 
 ORDEN   POR  total_gastado  DESC 
 LIMIT   100  ; 

Ejemplos Avanzados con SELECT
SQL

-- Insertar datos generados proceduralmente 
INSERT  INTO  calendario  ( fecha ,  dia_semana ,  es_festivo ) 
SELECT  
    fecha_generada , 
    EXTRACT ( DOW  FROM  fecha_generada ) , 
    CASE  
        WHEN  EXTRACT ( DOW  FROM  fecha_generada )  IN  ( 0 ,  6 )  THEN  true 
        ELSE  false 
    END 
FROM  generate_series ( 
    '2024-01-01' :: date , 
    '2024-12-31' :: date , 
    '1 day' :: interval 
)  AS  fecha_generada ; 

-- Insertar con window functions 
INSERT  INTO  ranking_empleados  ( empleado_id ,  ventas_mes ,  ranking ) 
SELECT  
    empleado_id , 
    SUM ( total )  as  ventas_mes , 
    ROW_NUMBER ( )  OVER  ( ORDER  BY  SUM ( total )  DESC )  as  ranking
 FROM  ventas
 WHERE  fecha  >=  DATE_TRUNC ( 'month' ,  CURRENT_DATE ) 
GROUP  BY  empleado_id ; 

6. INSERTAR CON DEVOLUCI√ìN
Obtener Datos de la Inserci√≥n
SQL

-- Obtener el ID generado (muy com√∫n) 
INSERT  INTO  usuarios  ( username ,  email )  
VALUES  ( 'nuevo_usuario' ,  'nuevo@email.com' ) 
RETURNING  id ; 
-- Devuelve: id = 1 

-- Obtener m√∫ltiples columnas 
INSERT  INTO  productos  ( nombre ,  precio ,  stock )  
VALUES  ( 'Nuevo Producto' ,  99.99 ,  50 ) 
RETURNING  id ,  nombre ,  precio ,  fecha_creacion ; 

-- Usar en expresiones 
INSERT  INTO  pedidos  ( cliente_id ,  total )  
VALUES  ( 1 ,  150.75 ) 
RETURNING  
    id , 
    numero_pedido , 
    total  *  1.21  as  total_con_iva ;   -- Calcular IVA 

-- Insertar m√∫ltiples filas y retornar todas 
INSERT  INTO  logs  ( nivel ,  mensaje )  VALUES 
( 'INFO' ,  'Mensaje 1' ) , 
( 'WARNING' ,  'Mensaje 2' ) , 
( 'ERROR' ,  'Mensaje 3' ) 
RETURNING  id ,  nivel ,  mensaje ,  CURRENT_TIMESTAMP  as  fecha_log ; 

-- Con UPDATE en la misma consulta (INSERT...SELECT...RETURNING) 
INSERT  INTO  auditoria_cambios  ( tabla ,  accion ,  datos_viejos ) 
SELECT  
    'usuarios' , 
    'UPDATE' , 
    row_to_json ( old_row ) 
FROM  usuarios old_row
 WHERE  old_row . id  =  1 
RETURNING  id ,  CURRENT_TIMESTAMP  as  fecha_auditoria ; 

Ejemplo Pr√°ctico con RETURNING
SQL

-- Proceso completo de creaci√≥n de pedido 
WITH  nuevo_pedido  AS  ( 
    INSERT  INTO  pedidos  ( cliente_id ,  total )  
    VALUES  ( 1 ,  0 )   -- Total inicial 0 
    RETURNING  id
 ) , 
detalles  AS  ( 
    INSERT  INTO  detalles_pedido  ( pedido_id ,  producto_id ,  cantidad ,  precio_unitario ) 
    SELECT  
        ( SELECT  id  FROM  nuevo_pedido ) , 
        producto_id , 
        cantidad , 
        precio
     FROM  carrito
     WHERE  usuario_id  =  1 
    RETURNING  pedido_id ,  SUM ( cantidad  *  precio_unitario )  as  subtotal
 ) 
UPDATE  pedidos p
 SET  total  =  d . subtotal
 FROM  detalles d
 WHERE  p . id  =  d . pedido_id
 RETURNING  p . id ,  p . numero_pedido ,  p . total ; 

7. UPSERT (INSERTAR EN CASO DE CONFLICTO)
Manejo de Conflictos con Claves √önicas
SQL

-- Sintaxis b√°sica de UPSERT 
INSERT  INTO  usuarios  ( id ,  username ,  email )  
VALUES  ( 1 ,  'jperez' ,  'juan@email.com' ) 
ON  CONFLICT  ( id )  DO  NOTHING ;   -- Si existe, no hace nada 

-- Actualizar si existe 
INSERT  INTO  productos  ( id ,  nombre ,  precio ,  stock )  
VALUES  ( 1 ,  'Laptop' ,  999.99 ,  10 ) 
ON  CONFLICT  ( id )  
DO  UPDATE  SET  
    precio  =  EXCLUDED . precio , 
    stock  =  productos . stock  +  EXCLUDED . stock , 
    fecha_actualizacion  =  CURRENT_TIMESTAMP ; 

-- WHERE condicional en el UPDATE 
INSERT  INTO  configuraciones  ( usuario_id ,  tema ,  notificaciones )  
VALUES  ( 1 ,  'oscuro' ,  true ) 
ON  CONFLICT  ( usuario_id )  
DO  UPDATE  SET  
    tema  =  EXCLUDED . tema , 
    notificaciones  =  EXCLUDED . notificaciones
 WHERE  configuraciones . usuario_id  =  1 ; 

-- M√∫ltiples columnas en la restricci√≥n 
INSERT  INTO  suscripciones  ( usuario_id ,  servicio_id ,  fecha_inicio )  
VALUES  ( 1 ,  3 ,  '2024-01-01' ) 
ON  CONFLICT  ( usuario_id ,  servicio_id )  
DO  UPDATE  SET  
    fecha_inicio  =  EXCLUDED . fecha_inicio , 
    activa  =  true ; 

Ejemplos Complejos de UPSERT
SQL

-- Contador de visitas con UPSERT 
INSERT  INTO  visitas_pagina  ( pagina_id ,  fecha ,  contador )  
VALUES  ( 'home' ,  CURRENT_DATE ,  1 ) 
ON  CONFLICT  ( pagina_id ,  fecha )  
DO  UPDATE  SET  
    contador  =  visitas_pagina . contador  +  1 , 
    ultima_visita  =  CURRENT_TIMESTAMP 
RETURNING  contador ; 

-- Sistema de votos/likes 
INSERT  INTO  votos  ( usuario_id ,  contenido_id ,  tipo )  
VALUES  ( 1 ,  100 ,  'like' ) 
ON  CONFLICT  ( usuario_id ,  contenido_id )  
DO  UPDATE  SET  
    tipo  =  EXCLUDED . tipo , 
    fecha_voto  =  CURRENT_TIMESTAMP 
RETURNING  
    ( CASE  
        WHEN  EXCLUDED . tipo  =  'like'  THEN  'Voto actualizado' 
        ELSE  'Voto eliminado' 
    END )  as  mensaje ; 

-- Carrito de compras 
INSERT  INTO  carrito_items  ( usuario_id ,  producto_id ,  cantidad )  
VALUES  ( 1 ,  5 ,  2 ) 
ON  CONFLICT  ( usuario_id ,  producto_id )  
DO  UPDATE  SET  
    cantidad  =  carrito_items . cantidad  +  EXCLUDED . cantidad , 
    fecha_actualizacion  =  CURRENT_TIMESTAMP 
WHERE  carrito_items . cantidad  +  EXCLUDED . cantidad  <=  10   -- L√≠mite de stock 
RETURNING  cantidad ; 

8. INSERCI√ìN DESDE ARCHIVOS
Usando COPY (Muy R√°pido para Grandes Vol√∫menes)
SQL

-- Copiar desde archivo CSV 
COPY clientes  ( nombre ,  email ,  telefono ,  fecha_registro ) 
FROM  '/ruta/al/archivo/clientes.csv' 
WITH  ( 
    FORMAT CSV , 
    HEADER  true , 
    DELIMITER  ',' , 
    NULL  '' , 
    ENCODING  'UTF8' 
) ; 

-- Copiar desde archivo con transformaciones 
COPY productos 
 FROM  '/ruta/al/archivo/productos.csv' 
WITH  ( 
    FORMAT CSV , 
    HEADER  true , 
    DELIMITER  ';' , 
    QUOTE  '"' , 
    ESCAPE  '\'
);

-- Copiar datos a archivo (exportar)
COPY (SELECT * FROM pedidos WHERE fecha >= ' 2024 - 01 - 01 ')
TO ' / ruta / de / salida / pedidos_2024 . csv '
WITH (
    FORMAT CSV,
    HEADER true,
    DELIMITER ' , ',
    ENCODING ' UTF8'
 ) ; 

COPY Avanzado
SQL

-- Especificar columnas espec√≠ficas 
COPY empleados  ( nombre ,  apellido ,  email ) 
FROM  STDIN
 WITH  ( FORMAT CSV ) ; 

-- Datos desde STDIN 
-- (Luego pegar los datos CSV) 

-- Con manejo de errores 
BEGIN ; 
CREATE  TEMP  TABLE  errores_copia  ( 
    linea_num  INT , 
    mensaje_error  TEXT , 
    datos  TEXT 
) ; 

COPY productos  FROM  '/ruta/productos.csv' 
WITH  ( 
    FORMAT CSV , 
    HEADER  true , 
    DELIMITER  ',' 
) 
LOG  ERRORS  INTO  errores_copia
KEEP ; 

-- Ver errores 
SELECT  *  FROM  errores_copia ; 

COMMIT ; 

Usando \copy en psql
intento

# Desde la l√≠nea de comandos de psql 
\ copy  ( SELECT * FROM clientes )  TO  'clientes.csv'  WITH CSV HEADER

 # Importar desde psql 
\ copy clientes FROM  'clientes.csv'  WITH CSV HEADER 

9. BUENAS PR√ÅCTICAS
Validaci√≥n y Seguridad
SQL

-- ‚ùå PELIGROSO: SQL Injection 
INSERT  INTO  usuarios  ( nombre )  VALUES  ( '$nombre' ) ;   -- Variable sin escapar 

-- ‚úÖ SEGURO: Usar par√°metros 
-- En Python: cursor.execute("INSERT INTO usuarios (nombre) VALUES (%s)", (nombre,)) 

-- ‚úÖ Validar datos antes de insertar 
INSERT  INTO  productos  ( nombre ,  precio ,  stock ) 
VALUES  ( 
    TRIM ( '  Laptop  ' ) ,   -- Eliminar espacios 
    GREATEST ( 0 ,  - 100 ) ,     -- Asegurar precio positivo (usar√° 0) 
    LEAST ( 1000 ,  1500 )      -- Limitar stock m√°ximo 
) ; 

-- ‚úÖ Usar CHECK constraints en la tabla 
CREATE  TABLE  productos  ( 
    id  SERIAL  PRIMARY  KEY , 
    nombre  VARCHAR ( 100 )  NOT  NULL , 
    precio  DECIMAL ( 10 , 2 )  CHECK  ( precio  >=  0 ) , 
    stock  INT  CHECK  ( stock  >=  0 ) , 
    categoria  VARCHAR ( 50 )  CHECK  ( categoria  IN  ( 'Electr√≥nica' ,  'Ropa' ,  'Hogar' ) ) 
) ; 

Rendimiento
SQL

-- ‚ùå INEFICIENTE: Inserci√≥n fila por fila en bucle 
FOR  i  IN  1. .1000  LOOP 
    INSERT  INTO  logs  ( mensaje )  VALUES  ( 'Mensaje '  ||  i ) ; 
END  LOOP ; 

-- ‚úÖ EFICIENTE: Inserci√≥n masiva 
INSERT  INTO  logs  ( mensaje ) 
SELECT  'Mensaje '  ||  generate_series ( 1 ,  1000 ) ; 

-- ‚úÖ Usar transacciones para m√∫ltiples inserciones 
BEGIN ; 
INSERT  INTO  tabla1  ( . . . )  VALUES  ( . . . ) ; 
INSERT  INTO  tabla2  ( . . . )  VALUES  ( . . . ) ; 
INSERT  INTO  tabla3  ( . . . )  VALUES  ( . . . ) ; 
COMMIT ; 

-- ‚úÖ Desactivar √≠ndices temporalmente para carga masiva 
-- (Solo para cargas MUY grandes) 
ALTER  TABLE  productos  DISABLE  TRIGGER  ALL ; 
-- ... realizar copia masiva ... 
ALTER  TABLE  productos  ENABLE  TRIGGER  ALL ; 

Mantenibilidad
SQL

-- ‚ùå CONFUSO: Inserci√≥n impl√≠cita 
INSERT  INTO  usuarios  VALUES  ( DEFAULT ,  'Juan' ,  NULL ,  . . . ) ; 

-- ‚úÖ CLARO: Especificar columnas expl√≠citamente 
INSERT  INTO  usuarios  ( 
    username , 
    email , 
    fecha_registro , 
    activo
 )  VALUES  ( 
    'jperez' , 
    'juan@email.com' , 
    CURRENT_DATE , 
    true 
) ; 

-- ‚úÖ Documentar valores especiales 
INSERT  INTO  transacciones  ( 
    tipo ,           -- 'C'=Compra, 'V'=Venta, 'D'=Devoluci√≥n 
    monto , 
    descripcion     -- Formato: "Producto - Cantidad" 
)  VALUES  ( 
    'C' , 
    150.75 , 
    'Laptop Dell - 1 unidad' 
) ; 

10. EJEMPLOS CON PYTHON
Clase Base para Inserci√≥n de Datos
pit√≥n

importar  psycopg2
 desde  psycopg2  importar  sql
 de  psycopg2  .  extras  importar  execute_batch
 desde  escribir  importar  Lista  ,  Diccionario  ,  Cualquiera  ,  Opcional
 importar  csv
 importar  json

 clase   PostgreSQLInserter  : 
     def   __init__  (  self  ,  par√°metros_de_conexi√≥n  )  : 
        self  .  par√°metros_de_conexi√≥n  =  par√°metros_de_conexi√≥n
        ser  .  conn  =   Ninguno 
        
     def   connect  (  self  )  : 
         """Establecer conexi√≥n""" 
        self.conn ‚Äã ‚Äã  =  psycopg2.connect ‚Äã ‚Äã  (  **  self.connection_params ‚Äã ‚Äã  ) 
         return  self.conn ‚Äã ‚Äã
    
     def   desconectar  (  self  )  : 
         """Cerrar conexi√≥n""" 
         if  self  .  conexi√≥n  : 
            self.conn.close  :  "  (  "  )  un 
    
     def   insert_single  (  self  ,  table  :   str  ,  data  :  Dict  )   -  >  Opcional  [  int  ]  : 
         """Insertar 
         if   not  self.conn  solo  registro  " 
            yo  .  conectar  (  ) 
        
        columnas  =  datos  .  claves  (  ) 
        valores  =   [  datos  [  col  ]   para  col  en  columnas  ] 
        
        consulta  =  sql  .  SQL  (  """
            INSERTAR EN {tabla} ({columnas})
            VALORES ({marcadores de posici√≥n})
            DEVOLVIENDO id
        """  )  .  formato  ( 
            tabla  =  sql  .  Identificador  (  tabla  )  , 
            columnas  =  sql  .  SQL  (  ', '  )  .  join  (  map  (  sql  .  Identificador  ,  columnas  )  )  , 
            marcadores de posici√≥n =  sql  .  SQL  (  ', '  )  .  join  (  sql  .  Placeholder  (  )   *   len  (  valores  )  ) 
         ) 
        
         try  : 
             con  self  .  conn  .  cursor  (  )   como  cursor  : 
                cursor  .execute ‚Äã  (  consulta  ,  valores  ) 
                resultado  =  cursor  .  fetchone  (  ) 
                self  .  conn  .  commit  (  ) 
                 devolver  resultado  [  0  ]   si  resultado  de lo contrario   Ninguno 
         excepto  Excepci√≥n  como  e  : 
            self.conn.rollback  self  )  Insertar  "  (  ) 
             print  (  f"Error al insertar:  {  e  }  "  ) 
             return   None 
    
     def   insert_batch  (  ,  :  table  :   str  ,  data_list  :  List  [  Dict  ]  ]   -  >  List  [  int  ]  : 
         "" 
         if   not  data_list  : 
             return   [  " " 
        
         if   not  self.conn  de forma eficiente "  registros  m√∫ltiples 
            ser  .  connect  (  ) 
        
         # Todas las filas deben tener las mismas columnas 
        columnas  =  lista_de_datos  [  0  ]  .claves ‚Äã  (  ) 
        values_list  =   [  [  row  [  col  ]   para  col  en  columnas  ]   para  fila  en  data_list  ] 
        
        consulta  =  sql  .  SQL  (  """
            INSERTAR EN {tabla} ({columnas})
            VALORES ({marcadores de posici√≥n})
            DEVOLVIENDO id
        """  )  .  formato  ( 
            tabla  =  sql  .  Identificador  (  tabla  )  , 
            columnas  =  sql  .  SQL  (  ', '  )  .  join  (  map  (  sql  .  Identificador  ,  columnas  )  )  , 
            marcadores de posici√≥n  =  sql  .  SQL  (  ', ' )  .  join  (  sql  .  Placeholder  (  )   *   len  (  columnas  )  ) 
         ) 
        
         try  : 
             with  self  .  conn  .  cursor  (  )   as  cursor  : 
                 # execute_batch es m√°s eficiente que un bucle 
                execute_batch  (  cursor  ,  consulta  ,  lista_de_valores  ) 
                resultados  =  cursor  .  fetchall  (  ) 
                self  .  conn  .  commit  (  ) 
                 devuelve   [  fila  [  0  ]   para  fila  en  resultados  ] 
         excepto  Excepci√≥n  como  e  : 
            self.conn.rollback  Error en inserci√≥n  "  int  "  (  ) 
             print  (  por lotes:  {  e  }  [  ) 
             return   ]  f " 
    
     def   upsert  (  self  ,  table  :   str  ,  data  :  Dict  ,  conflict_columns  :  List  [  str  ]  )   -  >  Optional  [  ]  :  " 
         ""UPSERT: Insertar o actualizar si existe 
         if   not  self.conn  :  "  " 
            yo  .  conectar  (  ) 
        
        columnas  =  datos  .  claves  (  ) 
        valores  =   [  datos  [  col  ]   para  col  en  columnas  ] 
        
         # Construir la parte SET del UPDATE 
        update_set  =  sql  .  SQL  (  ', '  )  .  join  (  [ 
            sql  .  SQL  (  "{} = EXCLUIDO.{}"  )  .  formato  ( 
                sql  .  Identificador  (  col  )  , 
                sql  .  Identificador  (  col  ) 
             est√° 
             para  col  en  columnas  si  col  no   en  conflict_columns
         ]  ) 
        
        consulta  =  sql  .  SQL  (  """
            INSERTAR EN {tabla} ({columnas})
            VALORES ({marcadores de posici√≥n})
            SOBRE EL CONFLICTO ({columnas_de_conflicto})
            ACTUALIZAR CONJUNTO {update_set}
            DEVOLVIENDO id
        """ )  .  formato  ( 
            tabla  =  sql  .  Identificador  (  tabla  )  , 
            columnas  =  sql  .  SQL  (  ', '  )  .  join  (  map  (  sql  .  Identificador  ,  columnas  )  )  , 
            marcadores de posici√≥n  =  sql  .  SQL  (  ', '  )  .  join  (  sql  .  Placeholder  (  )   *   len  (  valores  )  )  , 
            columnas_conflicto  =  sql.SQL ‚Äã ‚Äã  (  ,  )  .  join  (  map  (  sql.Identifier  ,  )  '  columnas_conflicto  )  ,  ' 
            conjunto_de_actualizaciones  =  conjunto_de_actualizaciones
         ) 
        
         prueba  : 
             con  self.conn.cursor ‚Äã ‚Äã ‚Äã  cursor  (  )   como ‚Äã  : 
                cursor  .execute ‚Äã  (  consulta  ,  valores  ) 
                resultado  =  cursor  .  fetchone  (  ) 
                self  .  conn  .  commit  (  ) 
                 devolver  resultado  [  0  ]   si  resultado  de lo contrario   Ninguno 
         excepto  Excepci√≥n  como  e  : 
            self.conn.rollback  "  )  }  {  (  ) 
             print  (  en UPSERT  e  (  f  "  self 
             return   None 
    
     def   insert_from_csv  str  ,  :  tabla  :   str  ,  csv_path  Error   ,  :  
                       delimitador  :   str   =   ','  ,  has_header  :   bool   =   True  )   -  >   int  : 
         """Insertar datos desde archivo CSV usando COPY""" 
         if   not  self  .  conexi√≥n  : 
            self  .  connect  (  ) 
        
         try  : 
             with  self  .  conn  .  cursor  (  )   as  cursor  : 
                 # Primero, crear tabla temporal 
                cursor  .ejecutar  "  (  f"" 
                    CREAR TABLA TEMPORAL temp_csv_data 
                    (COMO {  tabla  }  INCLUYENDO VALORES PREDETERMINADOS)
                    AL COMPROBAR, CAER
                """  ) 
                
                 # Copiar datos a tabla temporal 
                 with   open  (  csv_path  ,   'r'  ,  encoding  =  'utf-8'  )   as  f  : 
                    cursor  .copy_expert  (  f" " 
                         "
                        COPIAR temp_csv_data DESDE STDIN 
                        CON (
                            FORMATO CSV,
                            DELIMITER '  {  delimitador  }  ',
                            ENCABEZADO  {  tiene_encabezado  }  ,
                            CODIFICACI√ìN 'UTF8'
                        )
                        """  , 
                        F
                     ) 
                
                 # Insertar en tabla real, manejando duplicados 
                cursor  .ejecutar  "  (  f"" 
                    INSERTAR EN  {  tabla  } 
                    SELECCIONAR * DE temp_csv_data
                    SOBRE EL CONFLICTO NO HACER NADA
                """  ) 
                
                filas_afectadas  =  cursor  .  recuento_de_filas
                self.conn.commit ‚Äã ‚Äã  (  devuelve ‚Äã  ) 
                ‚Äã  filas_afectadas 
                
         excepto  Excepci√≥n  como  e  : 
            autoconexi√≥n ‚Äã ‚Äã .  rollback  (  ) 
             print  (  f"Error al importar CSV:  {  e  }  "  ) 
             return   0 
    
     def   bulk_insert_with_copy  (  self  ,  table  :   str  ,  data  :  List  [  Dict  ]  )   -  >   int  : 
         """Inserci√≥n masiva usando COPY desde memoria""" 
         if   not  self  .  conn  or   not  data  : 
             return   0 
        
         try  : 
             with  self  .  conn  .  cursor  (  )   as  cursor  : 
                 # Convertir datos a formato CSV en memoria 
                 import  io
                salida  =  io  .  StringIO  (  ) 
                
                 # Escribir datos como CSV 
                escritor  =  csv  .  DictWriter  (  salida  ,  nombres de campo  =  datos  [  0  ]  .  claves  (  )  ) 
                escritor  .  escritorrows  (  datos  ) 
                producci√≥n  .  buscar  (  0  ) 
                
                 # Usar COPY para carga r√°pida 
                cursor  .copiar_de ‚Äã  ( 
                    producci√≥n  , 
                    mesa  , 
                    sep  =  ','  , 
                    nulo  =  ''  , 
                    columnas  =  datos  [  0  ]  .  claves  (  ) 
                 ) 
                
                filas_afectadas  =  cursor  .  recuento_de_filas
                self.conn.commit ‚Äã ‚Äã  (  devuelve ‚Äã  ) 
                ‚Äã  filas_afectadas 
                
         excepto  Excepci√≥n  como  e  : 
            ser  .  conexi√≥n  .  rollback  (  ) 
             print  (  f"Error en inserci√≥n masiva:  {  e  }  "  ) 
             return   0 

 # Ejemplo de uso 
 if  __name__  ==   "__main__" : 
    # Configuraci√≥n de conexi√≥n 
    config  =  { 
        'dbname' :  'tienda_db' , 
        'user' :  'admin' , 
        'password' :  'password' , 
        'host' :  'localhost' , 
        'port' :  '5432' 
    } 
    
    inserter  =  PostgreSQLInserter ( config ) 
    inserter . connect ( ) 
    
    # 1. Insertar un solo cliente 
    cliente_id  =  inserter . insert_single ( 'clientes' ,  { 
        'nombre' :  'Juan P√©rez' , 
        'email' :  'juan@email.com' , 
        'telefono' :  '+34 600 123 456' , 
        'fecha_registro' :  '2024-01-15' , 
        'activo' :  True 
    } ) 
    print ( f"Cliente insertado con ID:  { cliente_id } " ) 
    
    # 2. Insertar m√∫ltiples productos 
    productos  =  [ 
        { 
            'nombre' :  'Laptop Dell' , 
            'descripcion' :  'Laptop 15 pulgadas, 16GB RAM' , 
            'precio' :  899.99 , 
            'stock' :  10 , 
            'categoria' :  'Electr√≥nica' 
        } , 
        { 
            'nombre' :  'Mouse Logitech' , 
            'descripcion' :  'Mouse inal√°mbrico' , 
            'precio' :  29.99 , 
            'stock' :  50 , 
            'categoria' :  'Perif√©ricos' 
        } , 
        { 
            'nombre' :  'Teclado Mec√°nico' , 
            'descripcion' :  'Teclado RGB switches azules' , 
            'precio' :  89.99 , 
            'stock' :  30 , 
            'categoria' :  'Perif√©ricos' 
        } 
    ] 
    
    producto_ids  =  inserter . insert_batch ( 'productos' ,  productos ) 
    print ( f"Productos insertados:  { len ( producto_ids ) } " ) 
    
    # 3. UPSERT para actualizar stock 
    stock_update  =  { 
        'producto_id' :  1 , 
        'almacen_id' :  1 , 
        'cantidad' :  5 , 
        'fecha_actualizacion' :  '2024-01-15' 
    } 
    
    stock_id  =  inserter . upsert ( 
        table = 'inventario' , 
        data = stock_update , 
        conflict_columns = [ 'producto_id' ,  'almacen_id' ] 
    ) 
    print ( f"Inventario actualizado con ID:  { stock_id } " ) 
    
    # 4. Insertar desde archivo CSV 
    rows_inserted  =  inserter . insert_from_csv ( 
        table = 'clientes' , 
        csv_path = 'clientes_nuevos.csv' , 
        delimiter = ',' , 
        has_header = True 
    ) 
    print ( f"Clientes importados desde CSV:  { rows_inserted } " ) 
    
    inserter . disconnect ( ) 

Ejemplo Avanzado: Sistema de Pedidos
pit√≥n

clase   OrderSystem  : 
     def   __init__  (  self  ,  db_config  )  : 
          mismo.db_config yo ‚Äã  =  db_config 
        self  .  conn  =   None 
    
     def   create_order  (  self  ,  client_id  :   int  ,  items  :  List  [  Dict  ]  )   -  >  Dict  : 
         """Crear un pedido completo con transacci√≥n""" 
         try  : 
            self.conn ‚Äã ‚Äã  =  psycopg2.connect ‚Äã ‚Äã  (  **  self.db_config ‚Äã ‚Äã  ) 
            ser  .  conexi√≥n  .  autocommit  =   False 
            
             con  self  .  conexi√≥n  .  cursor  (  )   como  cursor  : 
                 # 1. Crear el pedido 
                cursor  .ejecutar  (  "  ""
                    INSERTAR EN pedidos (cliente_id, total)
                    VALORES (%s, 0)
                    REGRESO id, numero_pedido, fecha_pedido
                """  ,   (  id_del_cliente  ,  )  ) 
                
                orden  =  cursor  .  fetchone  (  ) 
                id_del_pedido  ,  n√∫mero_del_pedido  ,  fecha_del_pedido  =  pedido
                
                total_amount  =   0 
                
                 # 2. Insertar items del pedido 
                 for  item  in  items  : 
                     # Verificar stock 
                    cursor  .ejecutar  (  "  ""
                        SELECCIONA precio, stock DE productos 
                        DONDE id = %s PARA ACTUALIZAR
                    """ ,  ( item [ 'producto_id' ] , ) ) 
                    
                    product  =  cursor . fetchone ( ) 
                    if  not  product : 
                        raise  ValueError ( f"Producto  { item [ 'producto_id' ] }  no existe" ) 
                    
                    price ,  stock  =  product
                    
                     if  stock  <  item [ 'cantidad' ] : 
                        raise  ValueError ( f"Stock insuficiente para producto  { item [ 'producto_id' ] } " ) 
                    
                    # Calcular subtotal 
                    subtotal  =  price  *  item [ 'cantidad' ] 
                    total_amount  +=  subtotal
                    
                     # Insertar detalle 
                    cursor . execute ( """
                        INSERT INTO detalles_pedido 
                        (pedido_id, producto_id, cantidad, precio_unitario, subtotal)
                        VALUES (%s, %s, %s, %s, %s)
                    """ ,  ( order_id ,  item [ 'producto_id' ] ,  item [ 'cantidad' ] ,  price ,  subtotal ) ) 
                    
                    # Actualizar stock 
                    cursor . execute ( """
                        UPDATE productos 
                        SET stock = stock - %s
                        WHERE id = %s
                    """ ,   (  item  [  'cantidad'  ]  ,  item  [  'producto_id'  ]  ) )  ) 
                
                 # 3. Actualizar total del pedido 
                cursor  .ejecutar  (  "  ""
                    ACTUALIZACI√ìN pedidos 
                    ESTABLECER total = %s
                    DONDE id = %s
                """  ,   (  total_amount  ,  order_id  )  ) 
                
                 # 4. Registrador en auditor√≠a 
                cursor  .ejecutar  (  "  ""
                    INSERTAR EN auditoria_pedidos 
                    (pedido_id, accion, detalles)
                    VALORES (%s, 'CREACION', %s)
                """  ,   (  order_id  ,  json  .  dumps  (  { 
                     'cliente_id'  :  client_id  , 
                     'total'  :  total_amount  , 
                     'items'  :  items  , 
                     'fecha'  :   str  (  order_date  ) 
                 }  )  )  ) 
                
                self.conn.commit  n√∫mero del  '  ,  importe  (  ) 
                
                 return   { 
                     'success'  True   ,  ' 
                     order_id'  :  id del pedido  ' 
                     order_number'  :  pedido  , 
                     total'  '  ,  : 
                     message'  :   'Pedido creado exitosamente' 
                 } 
                
         except  Exception  as  e  : 
             if  self.conn  :  total  : 
                self.conn.rollback  '  self.conn  :  :  (  ) 
             return   { 
                 'success'  False   ,  ' 
                 '  :   str  (  e  )  , 
                 'message'  '   crear el pedido 
             } 
         finally  : 
             if  :  al  error  Error 
                self.conn.close ‚Äã ‚Äã  (  def ‚Äã  ) 
    
    ‚Äã   pedidos_de_importaci√≥n_masiva (  self  ,  orders_data  :  List  [  Dict  ]  )   -  >  Dict  : 
         """Importaci√≥n masiva de pedidos optimizada""" 
         try  : 
            self.conn    psycopg2.connect  =  carga  COPY  Use  (  **  self.db_config io  para  ) 
            
             COPY 
             con  self.conn.cursor  (  cursor  la importaci√≥n  #  )  los datos   como  #  : 
                 Prepare 
                 para  masiva 
                 importar  csv
                
                 # Datos para pedidos 
                pedidos_salida  =  io  .  StringIO  (  ) 
                orders_writer  =  csv  .writer  orders_output  (  orders_data  ) 
                
                 para  pedido  en  :  el 
                    pedidos_escritor.writerow   writerow ( [ 
                        orden  [  'cliente_id'  ]  , 
                        orden  [  'total'  ]  , 
                        orden  .get  (  '  'estado'  ,   'pendiente  )  , 
                        orden.get  (  fecha_pedido  '  '  ,   'AHORA()'  ) 
                     ]  ) 
                
                orders_output.seek  (  0  pedidos  #  ) 
                
                 Cargar 
                cursor.copy_expert "  (  "   
                    COPIAR pedidos (customer_id, total, estado, pedido_cerrado)
                    DESDE STDIN CON CSV
                """ ,  pedidos_de_salida  ) 
                
                ser .  conn  .  commit  (  ) 
                
                 return   { 
                     'success'  :   True  , 
                     'imported'  :   len  (  orders_data  )  , 
                     'message'  :   f'Importados  {  len  (  orders_data  )  }  pedidos' 
                 } 
                
         except  Exception  as  e  : 
             if  self  .  conn  : 
                self.conn.rollback  )  :  :  (  }  ) 
             return   { 
                 √©xito  :   Falso  , 
                 error  e   str  (  :  '  , 
                 importado  '   0 
             ' 
         finalmente  : 
             si  self.conn  '  '  ' 
                ser  .  conexi√≥n  .  close  (  ) 

 # Uso del sistema de pedidos 
 if  __name__  ==   "__main__"  : 
    db_config  =   { 
         'dbname'  :   'tienda_db'  , 
         'usuario'  :   'admin'  , 
         'contrase√±a'  :   'contrase√±a'  , 
         'host'  :   'localhost' 
     } 
    
    order_system  =  OrderSystem  (  db_config  ) 
    
     # Crear un pedido 
    resultado  =  sistema_de_pedidos  .crear_pedido ‚Äã  ( 
        id_cliente  =  1  , 
        items  =  [ 
             {  'producto_id'  :   1  ,   'cantidad'  :   2  }  , 
             {  'producto_id'  :   2  ,   'cantidad'  :   1  } 
         ] 
     ) 
    
     print  (  resultado  ) 
    
     # Importaci√≥n masiva 
    pedidos_a_importaci√≥n  =   [ 
         {  'cliente_id'  :   1  ,   'total'  :   150.75  }  , 
         {  'cliente_id'  :   2  ,   'total'  :   89.99  }  , 
         {  'cliente_id'  :   3  ,   'total'  :   245.50  }  , 
         # ... m√°s pedidos 
     ] 
    
    resultado_de_importaci√≥n  =  sistema_de_pedidos  .importaci√≥n_masiva_de_pedidos  pedidos_a_importar  ( ‚Äã  ) 
     imprimir  (  resultado_de_importaci√≥n  ) 

Manejo de Errores y Validaci√≥n
pit√≥n

clase   SafeInserter  : 
     def   __init__  (  self  ,  connection  )  : 
        auto  .  conexi√≥n  =  conexi√≥n
    
     def   validar_y_insertar  (  self  ,  tabla  :   str  ,  datos  :  Dict  )   -  >  Dict  : 
         """Validar datos antes de insertar""" 
        validation_errors  =   [  ] 
        
         # Validaciones espec√≠ficas por tabla 
         if  table  ==   'clientes'  : 
             if   'email'   en  datos  y   no  self  .  _is_valid_email  (  datos  [  'correo electr√≥nico'  ]  )  : 
                validation_errors  .  append  (  'Email inv√°lido'  ) 
            
             if   'telefono'   in  data  and   not  self  .  _is_valid_phone  (  data  [  'telefono'  ]  )  : 
                errores_validaci√≥n  .  append  (  'Tel√©fono inv√°lido'  ) 
        
         elif  table  ==   'productos'  : 
             if   'precio'   in  data  and  data  [  'precio'  ]   <=   0  : 
                validation_errors  .  append  (  'Precio debe ser positivo'  ) 
            
             if   'stock'   in  data  and  data  [  'stock'  ]   <   0  : 
                errores_validaci√≥n  .  append  (  'Stock no puede ser negativo'  ) 
        
         if  validation_errors  : 
             return   { 
                 'success'  :   False  , 
                 'errors'  :  validation_errors  , 
                 'message'  :   'Errores de validaci√≥n' 
             } 
        
         # Intentar inserci√≥n 
         try  : 
             with  self  .  conexi√≥n  .  cursor  (  )   como  cursor  : 
                columnas  =   lista  (  datos  .  claves  (  )  ) 
                valores =   lista  (  datos  .  valores  (  )  ) 
                
                marcadores de posici√≥n  =   ', '  .  join  (  [  '%s'  ]   *   len  (  valores  )  ) 
                consulta  =   f"""
                    INSERTAR EN  {  tabla  }  (  {  ', '  .  join  (  columnas  )  }  )
                    VALORES (  {  marcadores de posici√≥n  }  )
                    DEVOLVIENDO id
                """ 
                
                cursor  .execute ‚Äã  (  consulta  ,  valores  ) 
                id_insertado  =  cursor  .  fetchone  (  )  [  0  ] 
                self.connection.commit  '  :  (  insertado  )  Registro 
                
                 return   { 
                     'success'  :   True  , 
                     'id'  insert_id  ,  ' 
                     '  '   exitosamente 
                 } 
                
         except  psycopg2.IntegrityError  e  :  as  :  message 
            ser  .  conexi√≥n  .  rollback  (  ) 
             return   { 
                 '√©xito'  :   Falso  , 
                 'error'  :   'Violaci√≥n de integridad'  , 
                 'detalle'  :   str  (  e  )  .  split  (  '\n'  )  [  0  ]  , 
                 'message'  :   'Posible duplicado o referencia inv√°lida' 
             } 
        
         excepto  psycopg2  .  Error  como  e  : 
            ser  .  conexi√≥n  .  rollback  (  ) 
             return   { 
                 'success'  :   False  , 
                 'error'  :   'Error de base de datos'  , 
                 'detail'  :   str  (  e  )  , 
                 'message'  :   'Error al insertar el registro' 
             } 
    
     def   _is_valid_email  (  self  ,  email  :   str  )   -  >   bool  : 
         """Validaci√≥n simple de email""" 
         import  re
        patr√≥n =  r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$' 
        return  bool ( re . match ( pattern ,  email ) ) 
    
    def  _is_valid_phone ( self ,  phone :  str )  - >  bool : 
        """Validaci√≥n simple de tel√©fono""" 
        import  re
         # Acepta n√∫meros con o sin prefijo internacional 
        pattern  =  r'^[\+]?[0-9\s\-\(\)]{7,15}$' 
        return  bool ( re . match ( pattern ,  phone ) ) 

# Uso con contexto seguro 
from  contextlib  import  contextmanager

 @contextmanager 
def  get_db_connection ( config ) : 
    """Context manager para conexiones seguras""" 
    conn  =  None 
    try : 
        conn  =  psycopg2 . connect ( ** config ) 
        yield  conn
     finally : 
        if  conn : 
            conn . close ( ) 

# Ejemplo de uso seguro 
if  __name__  ==  "__main__" : 
    with  get_db_connection ( db_config )  as  conn : 
        inserter  =  SafeInserter ( conn ) 
        
        # Insertar cliente v√°lido 
        result  =  inserter . validate_and_insert ( 'clientes' ,  { 
            'nombre' :  'Ana L√≥pez' , 
            'email' :  'ana@email.com' , 
            'telefono' :  '+34 912 345 678' 
        } ) 
        print ( f"Cliente insertado:  { result } " ) 
        
        # Intentar insertar cliente inv√°lido 
        result  =  inserter . validate_and_insert ( 'clientes' ,  { 
            'nombre' :  'Juan' , 
            'email' :  'email-invalido' , 
            'telefono' :  '123' 
        } ) 
        print ( f"Cliente inv√°lido:  { result } " ) 

EJERCICIOS PR√ÅCTICOS
Nivel B√°sico:

    Insertar 5 productos diferentes en una tabla de productos

    Insertar clientes con datos completos incluyendo fecha de registro autom√°tica

    Pr√°ctica con valores por defecto : Crear una tabla con columnas DEFAULT y insertar datos 

Nivel Intermedio:

    UPSERT de precios : Actualizar precios de productos, insertando si no existen

    Carga desde CSV : Importar datos de un archivo CSV a una tabla

    Inserci√≥n con subconsulta : Insertar datos calculados desde otras tablas 

Nivel Avanzado:

    Transacci√≥n completa : Insertar pedido con items, actualizar stock y registrar auditor√≠a

    Inserci√≥n masiva optimizada : Cargar 10,000 registros usando COPY

    Validaci√≥n compleja : Crear sistema de inserci√≥n con validaci√≥n de reglas de negocio 

CONSEJOS FINALES
Para M√°ximo Rendimiento:

    Usa INSERT m√∫ltiple en lugar de inserciones individuales

    Para cargas masivas (>10,000 filas) usa COPY

    Desactiva triggers e √≠ndices durante cargas masivas, luego react√≠valos

    Usa transacciones para agrupar inserciones relacionadas 

Para Integridad de Datos:

    Especifica siempre las columnas expl√≠citamente

    Usa constraints en la tabla (NOT NULL, CHECK, UNIQUE, FOREIGN KEY)

    Valida datos antes de insertar en la aplicaci√≥n

    Maneja errores con TRY-CATCH en tu c√≥digo 

Para Mantenibilidad:

    Documenta valores especiales en comentarios

    Usa RETURNING para obtener IDs generados

    Implementa auditor√≠a de cambios importantes

    Mant√©n backups antes de operaciones masivas 

¬øTe gustar√≠a profundizar en alg√∫n aspecto espec√≠fico de INSERT? Por ejemplo:

    M√°s ejemplos de UPSERT complejos

    T√©cnicas de optimizaci√≥n para millones de registros

    C√≥mo manejar inserciones en tablas particionadas

    Inserci√≥n con datos geogr√°ficos o JSON avanzados 

¬°Continuemos construyendo tu expertise en PostgreSQL! üöÄ 