ğŸ—„ï¸ Tipos de Bases de Datos: GuÃ­a Completa

Vamos a explorar en profundidad los diferentes tipos de bases de datos, sus caracterÃ­sticas, casos de uso y ejemplos prÃ¡cticos.
ÃNDICE

    ClasificaciÃ³n por Modelo de Datos

    Bases de Datos Relacionales (SQL)

    Bases de Datos NoSQL

    Bases de Datos en Memoria

    Bases de Datos de Series de Tiempo

    Bases de Datos GrÃ¡ficas

    Bases de Datos Espaciales

    Bases de Datos Distribuidas

    Bases de Datos MÃ³viles y Embebidas

    CÃ³mo Elegir la Base de Datos Correcta 

1. CLASIFICACIÃ“N POR MODELO DE DATOS
Arquitectura General
texto

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   TIPOS DE BASES DE DATOS           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Relacionales (SQL)       â”‚ 2. NoSQL              â”‚
â”‚    â€¢ PostgreSQL             â”‚   â€¢ Documentales      â”‚
â”‚    â€¢ MySQL                  â”‚   â€¢ Clave-Valor       â”‚
â”‚    â€¢ Oracle                 â”‚   â€¢ Column-family     â”‚
â”‚    â€¢ SQL Server             â”‚   â€¢ GrÃ¡ficas          â”‚
â”‚                             â”‚                       â”‚
â”‚ 3. En Memoria               â”‚ 4. Especializadas     â”‚
â”‚    â€¢ Redis                  â”‚   â€¢ Series de tiempo  â”‚
â”‚    â€¢ Memcached              â”‚   â€¢ Espaciales        â”‚
â”‚    â€¢ VoltDB                 â”‚   â€¢ Buscadores        â”‚
â”‚                             â”‚                       â”‚
â”‚ 5. Distribuidas             â”‚ 6. MÃ³viles/Embebidas â”‚
â”‚    â€¢ Cassandra              â”‚   â€¢ SQLite            â”‚
â”‚    â€¢ CockroachDB            â”‚   â€¢ Realm             â”‚
â”‚    â€¢ YugabyteDB             â”‚   â€¢ PouchDB           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 

2. BASES DE DATOS RELACIONALES (SQL)
CaracterÃ­sticas Principales

    ACID Compliance : Atomicidad, Consistencia, Aislamiento, Durabilidad

    Schema Estricto : Estructura definida de tablas, columnas, tipos de datos

    SQL (Structured Query Language) : Lenguaje estÃ¡ndar para consultas

    Integridad Referencial : Claves primarias y forÃ¡neas

    NormalizaciÃ³n : EliminaciÃ³n de redundancias 

Ventajas
pitÃ³n

"""
âœ… Fortalezas:
1. Consistencia fuerte (ACID)
2. Estructura organizada y predecible
3. Lenguaje SQL estandarizado
4. Amplio soporte y herramientas
5. Excelente para datos transaccionales
6. Soporte para JOINs complejos
""" 

Desventajas
pitÃ³n

"""
âŒ Limitaciones:
1. Escalabilidad horizontal limitada
2. Schema rÃ­gido (difÃ­cil cambiar estructura)
3. No optimizado para datos no estructurados
4. Puede ser sobrecarga para datos simples
5. JOINs costosos en grandes volÃºmenes
""" 

Principales Sistemas RDBMS
PostgreSQL (Mi favorito ğŸ˜Š)
SQL

-- CaracterÃ­sticas Ãºnicas: 
-- â€¢ Tipos de datos avanzados (JSON, arrays, hstore) 
-- â€¢ Extensiones poderosas (PostGIS, Full-text search) 
-- â€¢ Concurrencia multi-versiÃ³n (MVCC) 
-- â€¢ CÃ³digo abierto y comunidad activa 

CREATE  TABLE  empleados  ( 
    id  SERIAL  PRIMARY  KEY , 
    nombre  VARCHAR ( 100 ) , 
    datos JSONB ,   -- Soporte nativo JSON 
    habilidades  TEXT [ ] ,   -- Arrays 
    ubicacion GEOGRAPHY ( POINT )   -- PostGIS 
) ; 

-- Casos de uso: Aplicaciones empresariales, GIS, sistemas complejos 

MySQL/MariaDB
SQL

-- CaracterÃ­sticas: 
-- â€¢ Muy popular en web 
-- â€¢ MÃ¡s simple que PostgreSQL 
-- â€¢ Excelente rendimiento lectura 
-- â€¢ Amplia adopciÃ³n 

CREATE  TABLE  productos  ( 
    id  INT  AUTO_INCREMENT  PRIMARY  KEY , 
    nombre  VARCHAR ( 255 ) , 
    precio  DECIMAL ( 10 , 2 ) , 
    INDEX  idx_nombre  ( nombre ) 
)  ENGINE = InnoDB ; 

-- Casos de uso: WordPress, e-commerce, aplicaciones web 

Base de datos Oracle
SQL

-- CaracterÃ­sticas: 
-- â€¢ Enterprise-grade 
-- â€¢ Funcionalidades avanzadas 
-- â€¢ Alto costo de licencia 
-- â€¢ Amplio soporte corporativo 

-- PL/SQL avanzado 
CREATE  OR  REPLACE  PROCEDURE  actualizar_salario  AS 
BEGIN 
    UPDATE  empleados 
     SET  salario  =  salario  *  1.05 ; 
END ; 

-- Casos de uso: Grandes corporaciones, banca, sistemas crÃ­ticos 

Microsoft SQL Server
SQL

-- CaracterÃ­sticas: 
-- â€¢ IntegraciÃ³n con stack Microsoft 
-- â€¢ SQL Server Integration Services (SSIS) 
-- â€¢ Reporting Services (SSRS) 
-- â€¢ T-SQL (Transact-SQL) 

-- IntegraciÃ³n con .NET 
CREATE  PROCEDURE  sp_GetEmployees
 AS 
BEGIN 
    SELECT  *  FROM  Employees ; 
END ; 

-- Casos de uso: Empresas Microsoft, .NET applications 

CuÃ¡ndo Usar Bases de Datos Relacionales
pitÃ³n

"""
ğŸ“‹ ESCENARIOS IDEALES:

1. Sistemas Transaccionales (OLTP)
   â€¢ Bancos
   â€¢ Sistemas de ventas
   â€¢ Reservas

2. Datos Altamente Estructurados
   â€¢ CatÃ¡logos de productos
   â€¢ Sistemas de inventario
   â€¢ GestiÃ³n de clientes

3. Necesidad de ACID
   â€¢ Transferencias financieras
   â€¢ Sistemas de pago
   â€¢ Control de inventario

4. Consultas Complejas con JOINs
   â€¢ Reportes empresariales
   â€¢ AnÃ¡lisis de relaciones
   â€¢ Consultas ad-hoc
""" 

Ejemplo PrÃ¡ctico PostgreSQL con Python
pitÃ³n

import  psycopg2
 from  psycopg2 . extras  import  RealDictCursor

 class  SistemaBancario : 
    def  __init__ ( self ) : 
        self . conn  =  psycopg2 . connect ( 
            dbname = 'banco_db' , 
            user = 'admin' , 
            password = 'secret' , 
            host = 'localhost' 
        ) 
    
    def  transferencia ( self ,  origen ,  destino ,  monto ) : 
        """Ejemplo de transacciÃ³n ACID""" 
        try : 
            with  self . conn . cursor ( )  as  cursor : 
                # Iniciar transacciÃ³n 
                self . conn . autocommit  =  False 
                
                # Verificar fondos 
                cursor . execute ( 
                    "SELECT saldo FROM cuentas WHERE id = %s FOR UPDATE" , 
                    ( origen , ) 
                ) 
                saldo_actual  =  cursor . fetchone ( ) [ 0 ] 
                
                if  saldo_actual  <  monto : 
                    raise  ValueError ( "Fondos insuficientes" ) 
                
                # Retirar de origen 
                cursor . execute ( 
                    "UPDATE cuentas SET saldo = saldo - %s WHERE id = %s" , 
                    ( monto ,  origen ) 
                ) 
                
                # Depositar en destino 
                cursor . execute ( 
                    "UPDATE cuentas SET saldo = saldo + %s WHERE id = %s" , 
                    ( monto ,  destino ) 
                ) 
                
                # Registrar transacciÃ³n 
                cursor . execute ( 
                    """
                    INSERT INTO transacciones (origen, destino, monto, estado)
                    VALUES (%s, %s, %s, 'COMPLETADA')
                    """ , 
                    ( origen ,  destino ,  monto ) 
                ) 
                
                # Confirmar transacciÃ³n 
                self . conn . commit ( ) 
                return  True 
                
        except  Exception  as  e : 
            self . conn . rollback ( ) 
            print ( f"Error en transferencia:  { e } " ) 
            return  False 
    
    def  generar_reporte ( self ) : 
        """Consulta compleja con JOINs""" 
        with  self . conn . cursor ( cursor_factory = RealDictCursor )  as  cursor : 
            cursor . execute ( """
                SELECT 
                    c.nombre,
                    c.tipo_cuenta,
                    COUNT(t.id) as num_transacciones,
                    SUM(CASE 
                        WHEN t.origen = c.id THEN -t.monto 
                        WHEN t.destino = c.id THEN t.monto 
                        ELSE 0 
                    END) as saldo_total
                FROM clientes c
                LEFT JOIN cuentas cu ON c.id = cu.cliente_id
                LEFT JOIN transacciones t ON cu.id = t.origen OR cu.id = t.destino
                GROUP BY c.id, c.nombre, c.tipo_cuenta
                ORDER BY saldo_total DESC
            """ ) 
             devuelve  cursor  .fetchall  (  )  el 

3. BASES DE DATOS NOSQL
4 Tipos Principales de NoSQL
1. Bases de Datos Documentales
pitÃ³n

"""
ğŸ“„ BASES DOCUMENTALES:
â€¢ Almacenan datos en documentos (JSON, BSON, XML)
â€¢ Schema flexible
â€¢ Buenas para contenido jerÃ¡rquico

Ejemplos: MongoDB, CouchDB, Firebase Firestore
""" 

MongoDB (El mÃ¡s popular)
JavaScript

// MongoDB - Documentos JSON 
db . usuarios . insertOne ( { 
    _id :  ObjectId ( "507f1f77bcf86cd799439011" ) , 
    nombre :  "Juan PÃ©rez" , 
    email :  "juan@email.com" , 
    direccion :  { 
        calle :  "Av. Principal 123" , 
        ciudad :  "Madrid" , 
        pais :  "EspaÃ±a" 
    } , 
    hobbies :  [ "futbol" ,  "lectura" ,  "programacion" ] , 
    fecha_registro :  new  Date ( ) 
} ) ; 

// Consultas flexibles 
db . usuarios . find ( { 
    "direccion.ciudad" :  "Madrid" , 
    hobbies :  {  $ in :  [ "programacion" ]  } 
} ) ; 

Python con MongoDB
pitÃ³n

from  pymongo  import  MongoClient
 from  bson . objectid  import  ObjectId

 class  SistemaBlog : 
    def  __init__ ( self ) : 
        self . client  =  MongoClient ( 'localhost' ,  27017 ) 
        self . db  =  self . client . blog_db
    
     def  crear_post ( self ,  titulo ,  contenido ,  autor ,  etiquetas ) : 
        """Documento flexible con schema dinÃ¡mico""" 
        post  =  { 
            "titulo" :  titulo , 
            "contenido" :  contenido , 
            "autor" :  { 
                "id" :  autor [ "id" ] , 
                "nombre" :  autor [ "nombre" ] 
            } , 
            "etiquetas" :  etiquetas , 
            "comentarios" :  [ ] ,   # Array de subdocumentos 
            "metadata" :  { 
                "vistas" :  0 , 
                "likes" :  0 , 
                "fecha_publicacion" :  datetime . now ( ) 
            } , 
            "estado" :  "publicado" 
        } 
        
        return  self . db . posts . insert_one ( post ) 
    
    def  buscar_posts ( self ,  etiqueta = None ,  autor = None ) : 
        """Consultas flexibles""" 
        query  =  { } 
        if  etiqueta : 
            query [ "etiquetas" ]  =  etiqueta
         if  autor : 
            query [ "autor.nombre" ]  =  autor
        
         return  list ( self . db . posts . find ( query ) ) 

2. Bases de Datos Clave-Valor
pitÃ³n

"""
ğŸ”‘ BASES CLAVE-VALOR:
â€¢ Estructura simple: clave â†’ valor
â€¢ Altamente escalables
â€¢ Baja latencia
â€¢ No hay relaciones ni joins

Ejemplos: Redis, DynamoDB, etcd
""" 

Redis (En memoria, clave-valor avanzado)
pitÃ³n

import  redis
 import  json

 class  SistemaCache : 
    def  __init__ ( self ) : 
        self . r  =  redis . Redis ( host = 'localhost' ,  port = 6379 ,  db = 0 ) 
    
    def  cache_usuario ( self ,  user_id ,  user_data ,  ttl = 3600 ) : 
        """Almacenar datos de usuario en cache""" 
        # Serializar datos 
        serialized  =  json . dumps ( user_data ) 
        
        # Guardar con tiempo de expiraciÃ³n 
        self . r . setex ( f"user: { user_id } " ,  ttl ,  serialized ) 
    
    def  obtener_usuario ( self ,  user_id ) : 
        """Obtener datos del cache""" 
        cached  =  self . r . get ( f"user: { user_id } " ) 
        if  cached : 
            return  json . loads ( cached ) 
        return  None 
    
    def  contador_vistas ( self ,  post_id ) : 
        """Contador atÃ³mico""" 
        return  self . r . incr ( f"views:post: { post_id } " ) 
    
    def  leaderboard ( self ,  juego ,  usuario ,  puntos ) : 
        """Sorted set para rankings""" 
        self . r . zadd ( f"leaderboard: { juego } " ,  { usuario :  puntos } ) 
        return  self . r . zrevrange ( f"leaderboard: { juego } " ,  0 ,  9 ,  withscores = True ) 

Amazon DynamoDB (Clave-valor escalable)
pitÃ³n

importar  boto3
 desde  boto3  .  dynamodb  .  condiciones  importar  clave

 clase   DynamoDBManager  : 
     def   __init__  (  self  )  : 
        self.dynamodb  '  vote3.resource  =  "  '  us-east -  (  dynamodb'  ,  region_name  =  1'  ) 
    
     def   crear_table_sessions  (  self  )  : 
         """Tabla con particiÃ³n y clave de ordenaciÃ³n"" 
        tabla  =  self.dynamodb.create_table â€‹ â€‹  ( â€‹ â€‹ 
            TableName  =  'Sesiones de usuario'  , 
            KeySchema  =  [ 
                 { 
                     'AttributeName'  :   'usario_id'  , 
                     'KeyType'  :   'HASH'    # Clave de particiÃ³n 
                 }  , 
                 { 
                     'AttributeName'  :   'timestamp'  , 
                     'KeyType'  :   'RANGE'    # Clave de ordenaciÃ³n 
                 } 
             ]  , 
            AttributeDefinitions  =  [ 
                 { 
                     'AttributeName'  :   'user_id'  , 
                     'AttributeType'  :   'S'    # Cadena 
                 }  , 
                 { 
                     'AttributeName'  :   'timestamp'  , 
                     'AttributeType'  :   'N'    # NÃºmero 
                 } 
             ]  , 
            BillingMode  =  'PAY_PER_REQUEST' 
         ) 
         de retorno  tabla 
    
     def   save_session  (  self  ,  user_id  ,  session_data  )  : 
         """Insertar elemento""" 
        tabla  =  self.dynamodb.table â€‹ â€‹  (  SesionesDeUsuario  '  '  ) 
        
        item  =   { 
             'user_id'  :  user_id  , 
             'timestamp'  :   int  (  time  .  time  (  )  )  , 
             'datos'  :  session_data  , 
             'ttl'  :   int  (  time  .  time  (  )  )   +   86400    # Caduca en 24h 
         } 
        
        tabla  .put_item â€‹  (  ArtÃ­culo =  artÃ­culo  ) 

3. Bases de Datos Column-Family (Wide Column)
pitÃ³n

"""
ğŸ“Š BASES COLUMN-FAMILY:
â€¢ Similar a tablas pero columnas dinÃ¡micas
â€¢ Optimizado para consultas por columnas
â€¢ Excelente para anÃ¡lisis y big data

Ejemplos: Cassandra, HBase, ScyllaDB
""" 

Apache Cassandra (Distribuida, alta disponibilidad)
SQL

-- Cassandra CQL (similar a SQL pero diferente) 
CREATE  KEYSPACE ecommerce 
 WITH  replication  =  {
     'class' :  'SimpleStrategy' , 
    'replication_factor' :  3 
} ; 

-- Tabla optimizada para consultas especÃ­ficas 
CREATE  TABLE  productos_por_categoria  ( 
    categoria  text , 
    producto_id uuid , 
    nombre  text , 
    precio  decimal , 
    stock  int , 
    PRIMARY  KEY  ( categoria ,  producto_id ) 
)  WITH  CLUSTERING  ORDER  BY  ( producto_id  ASC ) ; 

-- Las consultas deben usar la clave de particiÃ³n 
SELECT  *  FROM  productos_por_categoria 
 WHERE  categoria  =  'ElectrÃ³nica' ; 

Python con Cassandra
pitÃ³n

from  cassandra . cluster  import  Cluster
 from  cassandra . query  import  BatchStatement

 class  SistemaEcommerceCassandra : 
    def  __init__ ( self ) : 
        self . cluster  =  Cluster ( [ '127.0.0.1' ] ) 
        self . session  =  self . cluster . connect ( 'ecommerce' ) 
    
    def  insertar_productos_lote ( self ,  productos ) : 
        """InserciÃ³n batch eficiente""" 
        insert_stmt  =  self . session . prepare ( """
            INSERT INTO productos_por_categoria 
            (categoria, producto_id, nombre, precio, stock)
            VALUES (?, ?, ?, ?, ?)
        """ ) 
        
        batch  =  BatchStatement ( ) 
        for  producto  in  productos : 
            batch . add ( insert_stmt ,  ( 
                producto [ 'categoria' ] , 
                producto [ 'id' ] , 
                producto [ 'nombre' ] , 
                producto [ 'precio' ] , 
                producto [ 'stock' ] 
            ) ) 
        
        self . session . execute ( batch ) 
    
    def  productos_por_categoria ( self ,  categoria ,  limite = 100 ) : 
        """Consulta optimizada""" 
        query  =  """
            SELECT * FROM productos_por_categoria 
            WHERE categoria = %s
            LIMIT %s
        """ 
        filas  =  self.sesiÃ³n.ejecutar â€‹ â€‹  categorÃ­a  )  (  consulta  ,   ( â€‹  ,  limite  )  ) 
         devolver   lista  (  filas â€‹ 

4. Bases de Datos GrÃ¡ficas (Las veremos en detalle en su secciÃ³n)
pitÃ³n

"""
ğŸ•¸ï¸ BASES GRÃFICAS:
â€¢ Datos como nodos y relaciones
â€¢ Optimizadas para relaciones complejas
â€¢ Consultas de recorrido de grafos

Ejemplos: Neo4j, Amazon Neptune, ArangoDB
""" 

Ventajas de NoSQL
pitÃ³n

"""
âœ… FORTALEZAS NOSQL:

1. Escalabilidad Horizontal
   â€¢ FÃ¡cil aÃ±adir mÃ¡s nodos
   â€¢ DistribuciÃ³n automÃ¡tica

2. Schema Flexible
   â€¢ Campos dinÃ¡micos
   â€¢ EvoluciÃ³n sin migraciones

3. Alto Rendimiento
   â€¢ Optimizadas para casos especÃ­ficos
   â€¢ Menos overhead

4. Tolerancia a Fallos
   â€¢ RÃ©plicas automÃ¡ticas
   â€¢ Alta disponibilidad

5. Modelos de Datos EspecÃ­ficos
   â€¢ Documentos para contenido
   â€¢ Grafos para relaciones
   â€¢ Clave-valor para cache
""" 

Desventajas de NoSQL
pitÃ³n

"""
âŒ LIMITACIONES NOSQL:

1. Consistencia Eventual (BASE, no ACID)
   â€¢ Datos pueden estar inconsistentes temporalmente

2. Sin JOINs
   â€¢ Debes desnormalizar datos
   â€¢ DuplicaciÃ³n posible

3. Curva de Aprendizaje
   â€¢ APIs propietarias
   â€¢ Menos estandarizado

4. Transacciones Limitadas
   â€¢ No soporte multi-documento en algunos
   â€¢ Consistencia mÃ¡s dÃ©bil

5. Menos Herramientas
   â€¢ Menos opciones de reporting
   â€¢ Menos integraciones
""" 

4. BASES DE DATOS EN MEMORIA
CaracterÃ­sticas
pitÃ³n

"""
âš¡ BASES EN MEMORIA (IN-MEMORY):
â€¢ Datos almacenados en RAM
â€¢ Latencia ultra baja (microsegundos)
â€¢ Persistencia opcional (snapshots)
â€¢ Ideal para cache, sesiones, rankings

Ejemplos: Redis, Memcached, Apache Ignite, VoltDB
""" 

Redis frente a Memcached
pitÃ³n

"""
ğŸ” COMPARACIÃ“N:

Redis:
âœ… Estructuras de datos ricas (sets, lists, hashes, sorted sets)
âœ… Persistencia opcional (RDB, AOF)
âœ… ReplicaciÃ³n maestro-esclavo
âœ… Publicar/Suscribir
âœ… Atomic operations
âœ… Lua scripting

Memcached:
âœ… MÃ¡s simple
âœ… Multi-threaded (mejor CPU usage)
âœ… Solo clave-valor simple
âœ… Sin persistencia
âœ… Cache puro
""" 

Casos de Uso Comunes
pitÃ³n

"""
ğŸ“‹ USOS TÃPICOS:

1. Sistema de Cache
   â€¢ Cache de consultas SQL
   â€¢ Cache de pÃ¡ginas web
   â€¢ Cache de sesiones

2. Sistemas en Tiempo Real
   â€¢ Leaderboards en juegos
   â€¢ Analytics en tiempo real
   â€¢ Sistemas de matching

3. Colas de Mensajes
   â€¢ Pub/Sub
   â€¢ Task queues
   â€¢ Stream processing

4. Almacenamiento de Sesiones
   â€¢ Sesiones de usuario web
   â€¢ Tokens JWT
   â€¢ Datos temporales
""" 

Ejemplo Completo: Sistema de Cache con Redis
pitÃ³n

importar  redis
  de importaciÃ³n pepinillos 
 importar  hashlib
 desde  functools  importar  wraps
  de importaciÃ³n tiempo 

 class   CacheDistribuido  : 
     def   __init__  (  self  ,  hosts  =  None  )  : 
         # Redis Cluster o sentinel para alta disponibilidad 
         if  hosts  : 
             from  rediscluster  import  RedisCluster
              mismo.redis yo â€‹  =  RedisCluster  ( 
                nodos_de_inicio  =  hosts  , 
                decode_responses  =  False 
             ) 
         de lo contrario  : 
              mismo.redis yo  redis.Redis  = â€‹ â€‹ â€‹  ( 
                host  =  'localhost'  , 
                puerto  =  6379  , 
                decode_responses  =  False 
             ) 
    
     def   cache_query  (  self  ,  ttl  =  300  )  : 
         """Decorador para cachear resultados de funciones""" 
         def   decorator  (  func  )  : 
             @wraps  (  func  ) 
             def   wrapper  (  *  args  ,   **  kwargs  )  : 
                 # Crear clave Ãºnica para la consulta 
                partes_clave  =   [ 
                    func  .  __mÃ³dulo__  , 
                    func  .__  name__  , 
                     str  (  args  )  , 
                     str  (  kwargs  ) 
                 ] 
                cache_key  =  hashlib  .  md5  ( 
                     "::"  .  join  (  key_parts  )  .  encode  (  ) 
                 )  .  hexdigest  (  ) 
                
                 # Intentar obtener el cachÃ© 
                almacenado en cachÃ©  =  yo  .  redis  .  obtener  (  cache_key  ) 
                 si  estÃ¡ en cachÃ©  : 
                     devolver  pickle  .  cargas  (  cached  ) 
                
                 # Ejecutar funciÃ³n y cachear resultado 
                result  =  func ( * args ,  ** kwargs ) 
                self . redis . setex ( 
                    cache_key , 
                    ttl , 
                    pickle . dumps ( result ) 
                ) 
                return  result
             return  wrapper
         return  decorator
    
     def  rate_limiter ( self ,  key ,  limit ,  window ) : 
        """Limitador de tasa usando Redis""" 
        current  =  int ( time . time ( ) ) 
        window_start  =  current  -  window
        
         # Usar pipeline para operaciones atÃ³micas 
        pipe  =  self . redis . pipeline ( ) 
        
        # Eliminar requests fuera de la ventana 
        pipe . zremrangebyscore ( key ,  0 ,  window_start ) 
        
        # Contar requests en la ventana 
        pipe . zcard ( key ) 
        
        # AÃ±adir nuevo request 
        pipe . zadd ( key ,  { str ( current ) :  current } ) 
        
        # Establecer expiraciÃ³n 
        pipe . expire ( key ,  window ) 
        
        results  =  pipe . execute ( ) 
        request_count  =  results [ 1 ] 
        
        return  request_count  <  limit

 # Uso del sistema de cache 
cache  =  CacheDistribuido ( ) 

@cache . cache_query ( ttl = 60 )   # Cache por 60 segundos 
def  obtener_usuario_detallado ( user_id ) : 
    """Consulta pesada a base de datos""" 
    time . sleep ( 2 )   # Simular consulta lenta 
    return  { 
        "id" :  user_id , 
        "nombre" :  f"Usuario  { user_id } " , 
        "datos" :  "..."  *  1000 
    } 

# Primer llamado: va a la DB 
usuario1  =  obtener_usuario_detallado ( 1 )   # ~2 segundos 

# Segundo llamado: viene del cache 
usuario2  =  obtener_usuario_detallado ( 1 )   # ~0.001 segundos 

VoltDB: Base de Datos Transaccional en Memoria
SQL

-- VoltDB: SQL + In-Memory + ACID 
CREATE  TABLE  transacciones_financieras  ( 
    id  BIGINT  NOT  NULL , 
    cuenta_origen  BIGINT , 
    cuenta_destino  BIGINT , 
    monto  DECIMAL , 
    fecha  TIMESTAMP , 
    estado  VARCHAR ( 20 ) , 
    PRIMARY  KEY  ( id ) 
) ; 

-- Procedimientos almacenados para lÃ³gica de negocio 
CREATE  PROCEDURE  
    procesar_transferencia 
 PARTITION  ON  TABLE  transacciones_financieras 
 COLUMN  cuenta_origen
 AS 
    INSERT  INTO  transacciones_financieras 
     VALUES  ( ? ,  ? ,  ? ,  ? ,  NOW ( ) ,  'PROCESANDO' ) ; 
    
    UPDATE  cuentas 
     SET  saldo  =  saldo  -  ? 
     WHERE  id  =  ? ; 
    
    UPDATE  cuentas 
     SET  saldo  =  saldo  +  ? 
     WHERE  id  =  ? ; 
    
    UPDATE  transacciones_financieras 
     SET  estado  =  'COMPLETADA'  
    WHERE  id  =  ? ; 

5. BASES DE DATOS DE SERIES DE TIEMPO
CaracterÃ­sticas Ãšnicas
pitÃ³n

"""
ğŸ“ˆ BASES DE SERIES DE TIEMPO (TSDB):
â€¢ Optimizadas para datos temporales
â€¢ CompresiÃ³n eficiente
â€¢ Consultas por rangos de tiempo
â€¢ Downsampling automÃ¡tico

Ejemplos: InfluxDB, TimescaleDB, Prometheus, ClickHouse
""" 

InfluxDB (TSDB especializada)
SQL

-- Lenguaje de consulta Flux de InfluxDB 
 from  (  bucket:  "iot_sensors"  ) 
   |  >  range  (  start  :  -  1  h  ) 
   |  >  filter  (  fn:  (  r  )   =  >  r  .  _measurement  =  =   "temperature"  ) 
   |  >  filter  (  fn:  (  r  )   =  >  r  .  sensor_id  =  =   "sensor_001"  ) 
   |  >  aggregateWindow  (  every:  1  m  ,  fn: mean  ) 
   |  >  yield  (  name:  "mean_temperature"  ) 

 -- Los datos se almacenan como: 
 -- Measurement, Tag1=Value1, Tag2=Value2 Field1=Value, Field2=Value Timestamp 

TimescaleDB (PostgreSQL + Series temporales)
SQL

-- TimescaleDB: PostgreSQL con superpoderes de series de tiempo 

-- Crear tabla como hypertable 
CREATE  TABLE  metricas_iot  ( 
    tiempo TIMESTAMPTZ  NOT  NULL , 
    dispositivo_id  TEXT  NOT  NULL , 
    temperatura  DOUBLE  PRECISION , 
    humedad  DOUBLE  PRECISION , 
    presion  DOUBLE  PRECISION 
) ; 

-- Convertir a hypertable 
SELECT  create_hypertable ( 'metricas_iot' ,  'tiempo' ) ; 

-- Consultas optimizadas para tiempo 
SELECT  
    time_bucket ( '1 hour' ,  tiempo )  as  hora , 
    dispositivo_id , 
    avg ( temperatura )  as  temp_promedio , 
    max ( temperatura )  as  temp_maxima
 FROM  metricas_iot
 WHERE  tiempo  >  NOW ( )  -  INTERVAL  '7 days' 
GROUP  BY  hora ,  dispositivo_id
 ORDER  BY  hora  DESC ; 

-- PolÃ­ticas de retenciÃ³n automÃ¡tica 
SELECT  add_retention_policy ( 'metricas_iot' ,  INTERVAL  '90 days' ) ; 

Python con TimescaleDB
pitÃ³n

importar  psycopg2
 importar  pandas  como  pd
 desde  datetime  importar  datetime  ,  timedelta

 clase   SistemaIoT  : 
     def   __init__  (  auto  )  : 
        self.conn â€‹ â€‹  =  psycopg2.connect â€‹ â€‹  ( 
            nombre_base_datos  =  'iot_db'  , 
            usuario  =  'admin'  , 
            contraseÃ±a  =  'secreto'  , 
            host  =  'localhost' 
         ) 
    
     def   insertar_metricas  (  self  ,  dispositivo_id  ,  mÃ©tricas  )  : 
         """InserciÃ³n eficiente de datos temporales""" 
         with  self  .  conexiÃ³n  .  cursor  (  )   as  cursor  : 
             # Usar copy_from para inserciÃ³n masiva 
            datos  =   [  ] 
             para  marca de tiempo  ,  valores  en  mÃ©tricas  .  elementos  (  )  : 
                datos  .append â€‹  (  ( 
                    marca de tiempo  , 
                    dispositivo_id  , 
                    valores  .get  ,  (  'temperatura  )  ' 
                    valores  .  get  (  'humedad'  )  , 
                    valores  .  get  (  'presion'  ) 
                 )  ) 
            
             # Crear DataFrame y usar copy_expert 
            df  =  pd  .  DataFrame  (  datos  ,  columnas  =  [ 
                 'tiempo'  ,   'dispositivo_id'  ,  
                 'temperatura'  ,   'humedad'  ,   'presion' 
             ]  ) 
            
             de  io  import  StringIO
            salida  =  StringIO  (  ) 
            df  .  to_csv  (  salida  ,  sep  =  '\t'  ,  encabezado  =  False  ,  Ã­ndice  =  False  ) 
            producciÃ³n .  buscar  (  0  ) 
            
            cursor  .copy_expert  " COPIAR  ( 
                 metricas_iot DESDE STDIN CON (FORMATO CSV, DELIMITADOR '\t')"  , 
                producciÃ³n
             ) 
            
            ser  .  conexiÃ³n  .  commit  (  ) 
    
     def   obtener_tendencias  (  self  ,  dispositivo_id  ,  dias  =  7  )  : 
         """AnÃ¡lisis de tendencias temporales""" 
         with  self  .  conexiÃ³n  .  cursor  (  )   como  cursor  : 
            cursor  .ejecutar  (  "  ""
                SELECCIONAR 
                    time_bucket('1 hora', tiempo) como bucket,
                    AVG(temperatura) como temp_avg,
                    PERCENTIL_CONT(0.5) DENTRO DEL GRUPO (ORDENAR POR temperatura) como temp_median,
                    MAX(temperatura) como temp_max,
                    MIN(temperatura) como temp_min
                DESDE metricas_iot
                DONDE dispositivo_id = %s
                Y tiempo > AHORA() - INTERVALO %s
                AGRUPAR POR cubo
                ORDENAR POR cubo DESC
            """  ,   (  dispositivo_id  ,   f'  {  dias  }  dÃ­as  )  ) 
            
             regresa  cursor  .fetchall  (  )  ' 

Casos de Uso de TSDB
pitÃ³n

"""
ğŸ“‹ APLICACIONES COMUNES:

1. IoT y Sensores
   â€¢ Dispositivos inteligentes
   â€¢ Sensores industriales
   â€¢ Monitoreo ambiental

2. MÃ©tricas de Aplicaciones
   â€¢ APM (Application Performance Monitoring)
   â€¢ Logs de servidores
   â€¢ MÃ©tricas de negocio

3. Finanzas
   â€¢ Precios de acciones
   â€¢ Transacciones en tiempo real
   â€¢ AnÃ¡lisis de mercado

4. DevOps
   â€¢ MÃ©tricas de infraestructura
   â€¢ Logs de contenedores
   â€¢ Monitoreo de servicios
""" 

6. BASES DE DATOS GRÃFICAS
Conceptos Fundamentales
pitÃ³n

"""
ğŸ•¸ï¸ CONCEPTOS DE BASES GRÃFICAS:

Nodos (VÃ©rtices):
â€¢ Entidades (personas, productos, lugares)
â€¢ Propiedades (atributos)

Relaciones (Aristas/Edges):
â€¢ Conexiones entre nodos
â€¢ Direccionales o no direccionales
â€¢ TambiÃ©n pueden tener propiedades

Ejemplos: Neo4j, Amazon Neptune, JanusGraph, ArangoDB
""" 

Neo4j (LÃ­der en bases grÃ¡ficas)
cifrar

--  Cypher Query  Language  ( Neo4j ) 

// Crear nodos 
CREATE  ( juan : Persona  { 
    nombre :  "Juan PÃ©rez" , 
    edad :  30 , 
    email :  "juan@email.com" 
} ) 

CREATE  ( maria : Persona  { 
    nombre :  "MarÃ­a GarcÃ­a" , 
    edad :  28 
} ) 

CREATE  ( python : Lenguaje  { 
    nombre :  "Python" , 
    tipo :  "ProgramaciÃ³n" 
} ) 

// Crear relaciones 
CREATE  ( juan ) - [ : AMIGO_DE  { 
    desde :  "2020-01-15" , 
    cercania :  "alta" 
} ] -> ( maria ) 

CREATE  ( juan ) - [ : SABE ] -> ( python ) 
CREATE  ( maria ) - [ : ESTA_APRENDIENDO ] -> ( python ) 

// Consultas de grafos 
// Encontrar amigos de amigos 
MATCH  ( p : Persona  { nombre :  "Juan PÃ©rez" } ) - [ : AMIGO_DE * 2 .. 2 ] - ( amigoDeAmigo ) 
RETURN  amigoDeAmigo . nombre

 // Recomendaciones: Personas que saben lo mismo que Juan 
MATCH  ( juan : Persona  { nombre :  "Juan PÃ©rez" } ) - [ : SABE ] -> ( lenguaje ) <- [ : SABE ] - ( personaSimilar ) 
WHERE  juan  <>  personaSimilar
 RETURN  personaSimilar . nombre ,  COUNT ( lenguaje )  AS  lenguajesEnComun
 ORDER  BY  lenguajesEnComun  DESC 

Python con Neo4j
pitÃ³n

from  neo4j  import  GraphDatabase
 import  pandas  as  pd

 class  SistemaRecomendacionGrafo : 
    def  __init__ ( self ,  uri ,  user ,  password ) : 
        self . driver  =  GraphDatabase . driver ( uri ,  auth = ( user ,  password ) ) 
    
    def  close ( self ) : 
        self . driver . close ( ) 
    
    def  crear_grafo_productos ( self ) : 
        """Crear grafo de productos y relaciones""" 
        with  self . driver . session ( )  as  session : 
            # Crear nodos de productos 
            session . run ( """
                CREATE (p1:Producto {
                    id: 'P001',
                    nombre: 'Laptop Gaming',
                    categoria: 'ElectrÃ³nica',
                    precio: 1200
                })
                CREATE (p2:Producto {
                    id: 'P002',
                    nombre: 'Mouse Gaming',
                    categoria: 'PerifÃ©ricos',
                    precio: 80
                })
                CREATE (p3:Producto {
                    id: 'P003',
                    nombre: 'Teclado MecÃ¡nico',
                    categoria: 'PerifÃ©ricos',
                    precio: 120
                })
            """ ) 
            
            # Crear relaciones 
            session . run ( """
                MATCH (p1:Producto {id: 'P001'})
                MATCH (p2:Producto {id: 'P002'})
                MATCH (p3:Producto {id: 'P003'})
                CREATE (p1)-[:COMPATIBLE_CON]->(p2)
                CREATE (p1)-[:COMPATIBLE_CON]->(p3)
                CREATE (p2)-[:RELACIONADO_A]->(p3)
            """ ) 
    
    def  recomendar_productos ( self ,  producto_id ) : 
        """Recomendar productos basados en relaciones""" 
        with  self . driver . session ( )  as  session : 
            result  =  session . run ( """
                MATCH (p:Producto {id: $producto_id})-[:COMPATIBLE_CON|RELACIONADO_A*1..2]-(recomendado)
                WHERE p <> recomendado
                RETURN DISTINCT recomendado.id as id,
                       recomendado.nombre as nombre,
                       recomendado.precio as precio,
                       COUNT(*) as fuerza_relacion
                ORDER BY fuerza_relacion DESC
                LIMIT 5
            """ ,  producto_id = producto_id ) 
            
            return  [  dict  (  registro  )   para  registro  en  resultado  ] 
    
     def   analizar_red_clientes  (  self  )  : 
         """AnÃ¡lisis de red de clientes""" 
         with  self  .  conductor  .  sesiÃ³n  (  )   como  sesiÃ³n  : 
            resultado  =  sesiÃ³n.run "  (  "   
                Encontrar comunidades utilizando el algoritmo de Lovaina
                LLAMA a gds.graph.project(
                    'clientes rojos',
                    'Cliente',
                    {
                        HA_COMPRADO_JUNTO: {
                            orientaciÃ³n: 'NO DIRIGIDA',
                            propiedades: 'peso'
                        }
                    }
                )
                
                LLAMAR gds.louvain.stream('clientes-rojo')
                YIELD nodeId, communityId
                DEVUELVE gds.util.asNode(nodeId).id como client_id,
                       communityId como comunidad,
                       COUNT(*) como tamaÃ±o de la comunidad
                ORDENAR POR talla_comunidad DESC
            """ ) 
            
             return  pd  .  DataFrame  (  [  dict  (  registro  )   para  el registro  en  el resultado  ]  ) 

 # Uso del sistema 
sistema =  SistemaRecomendacionGrafo ( "bolt://localhost:7687" ,  "neo4j" ,  "password" ) 

# Crear datos de ejemplo 
sistema . crear_grafo_productos ( ) 

# Obtener recomendaciones 
recomendaciones  =  sistema . recomendar_productos ( "P001" ) 
print ( "Productos recomendados:" ,  recomendaciones ) 

sistema . close ( ) 

Casos de Uso de Bases GrÃ¡ficas
pitÃ³n

"""
ğŸ“‹ APLICACIONES IDEALES:

1. Sistemas de RecomendaciÃ³n
   â€¢ "Clientes que compraron X tambiÃ©n compraron Y"
   â€¢ Recomendaciones de contenido
   â€¢ Matchmaking en redes sociales

2. Redes Sociales
   â€¢ Amistades y conexiones
   â€¢ Seguidores y seguidos
   â€¢ Grupos y comunidades

3. DetecciÃ³n de Fraude
   â€¢ Patrones de transacciones
   â€¢ Redes de fraude
   â€¢ AnÃ¡lisis de comportamiento

4. GestiÃ³n del Conocimiento
   â€¢ Grafos de conocimiento
   â€¢ OntologÃ­as y taxonomÃ­as
   â€¢ Sistemas expertos

5. IoT y Dispositivos
   â€¢ Redes de sensores
   â€¢ Relaciones entre dispositivos
   â€¢ AnÃ¡lisis de dependencias
""" 

7. BASES DE DATOS ESPACIALES
PostGIS (ExtensiÃ³n de PostgreSQL)
SQL

-- PostGIS: PostgreSQL con capacidades espaciales 

-- Crear tabla con geometrÃ­as 
CREATE  TABLE  lugares  ( 
    id  SERIAL  PRIMARY  KEY , 
    nombre  VARCHAR ( 100 ) , 
    tipo  VARCHAR ( 50 ) , 
    ubicacion GEOGRAPHY ( POINT ,  4326 ) ,   -- Lat/Long 
    area GEOGRAPHY ( POLYGON ,  4326 )       -- PolÃ­gonos 
) ; 

-- Insertar datos espaciales 
INSERT  INTO  lugares  ( nombre ,  tipo ,  ubicacion )  VALUES 
( 'Oficina Central' ,  'oficina' ,  
    ST_GeogFromText ( 'POINT(-3.703790 40.416775)' ) ) ,   -- Madrid 
( 'AlmacÃ©n Norte' ,  'almacen' , 
    ST_GeogFromText ( 'POINT(-0.887712 41.648823)' ) ) ;    -- Zaragoza 

-- Consultas espaciales 
-- 1. Distancia entre puntos 
SELECT  
    a . nombre  as  lugar_a , 
    b . nombre  as  lugar_b , 
    ST_Distance ( a . ubicacion ,  b . ubicacion )  as  distancia_metros
 FROM  lugares a ,  lugares b
 WHERE  a . id  =  1  AND  b . id  =  2 ; 

-- 2. Puntos dentro de un radio 
SELECT  nombre ,  tipo
 FROM  lugares
 WHERE  ST_DWithin ( 
    ubicacion , 
    ST_GeogFromText ( 'POINT(-3.703790 40.416775)' ) , 
    5000   -- 5km de radio 
) ; 

-- 3. IntersecciÃ³n de Ã¡reas 
SELECT  l1 . nombre ,  l2 . nombre
 FROM  lugares l1 ,  lugares l2
 WHERE l1.id â€‹ â€‹  <  l2.id â€‹  > 
 AND  ST_Intersects  (  l1.Ã¡rea â€‹ â€‹  ,  l2.Ã¡rea â€‹ â€‹  )  ; 

 -- 4. Buffer alrededor del punto 
 SELECT  ST_AsText  ( 
    ST_Buffer  ( 
        ST_GeogFromText  (  'POINT(-3.703790 40.416775)'  )  , 
         1000    -- 1 km de bÃºfer 
     ) 
 )   como  area_buffer  ; 

Sistema de GeolocalizaciÃ³n con PostGIS
pitÃ³n

importar  psycopg2
 de  psychopg2  .  extras  importar  RealDictCursor
 desde  geopy  .  distancia  importar  distancia

 clase   SistemaGeolocalizacion  : 
     def   __init__  (  self  )  : 
        yo  .  conn  =  psychopg2  .  connect  ( 
            nombre_base_de_datos  =  'geodb'  , 
            usuario  =  'postgres'  , 
            contraseÃ±a  =  'secreto'  , 
            host  =  'localhost' 
         ) 
        self.conn.autocommit  ,  )  metros  cercas  =   True 
    
     def   buscar_cercanos  (  self  ,  lat  ,  lon  ,  radio_km  =  type  "  None  a  : 
         coordenada 
         with  self.conn.cursor  (  cursor_factory  :  cursor  =  a  lugares  RealDictCursor  )   as  una  Buscar 
             # Convertir radio 
            radio_metros  =  radio_km  *   1000 
            
            consulta  =   """
                SELECCIONAR 
                    identificaciÃ³n,
                    nombre,
                    tipo,
                    ST_X(ubicacion::geometria) como longitud,
                    ST_Y(ubicacion::geometria) como latitud,
                    ST_Distance(ubicacion, ST_SetSRID(ST_MakePoint(%s, %s), 4326)::geografÃ­a) as distancia_metros
                DESDE lugares
                DONDE ST_DWithin(
                    ubicaciÃ³n,
                    ST_SetSRID(ST_MakePoint(%s, %s), 4326)::geografÃ­a,
                    %s
                )
            """ 
            
            params  =  [ lon ,  lat ,  lon ,  lat ,  radio_metros ] 
            
            if  tipo : 
                query  +=  " AND tipo = %s" 
                params . append ( tipo ) 
            
            query  +=  " ORDER BY distancia_metros" 
            
            cursor . execute ( query ,  params ) 
            return  cursor . fetchall ( ) 
    
    def  calcular_ruta_optima ( self ,  puntos ) : 
        """Calcular ruta Ã³ptima usando PostGIS y pgRouting""" 
        with  self . conn . cursor ( )  as  cursor : 
            # Asumiendo que tenemos una tabla de calles con pgRouting 
            cursor . execute ( """
                SELECT 
                    seq,
                    node,
                    edge,
                    cost,
                    agg_cost,
                    ST_AsText(geom) as geometria
                FROM pgr_dijkstra(
                    'SELECT id, source, target, cost, reverse_cost FROM calles',
                    %s,  -- nodo inicio
                    %s,  -- nodo fin
                    directed := true
                ) as ruta
                JOIN calles ON ruta.edge = calles.id
                ORDER BY seq
            """ ,  ( puntos [ 0 ] ,  puntos [ 1 ] ) ) 
            
            return  cursor . fetchall ( ) 
    
    def  densidad_puntos ( self ,  area_geojson ) : 
        """Calcular densidad de puntos en un Ã¡rea""" 
        with  self . conn . cursor ( )  as  cursor : 
            cursor . execute ( """
                WITH area AS (
                    SELECT ST_GeomFromGeoJSON(%s)::geography as geom
                ),
                puntos_en_area AS (
                    SELECT COUNT(*) as total
                    FROM lugares l, area a
                    WHERE ST_Within(l.ubicacion::geometry, a.geom::geometry)
                ),
                area_metros AS (
                    SELECT ST_Area(geom) as area_m2
                    FROM area
                )
                SELECT 
                    pa.total as puntos,
                    aa.area_m2,
                    (pa.total / aa.area_m2 * 1000000) as densidad_por_km2
                FROM puntos_en_area pa, area_metros aa
            """ ,  ( area_geojson , ) ) 
            
            return  cursor . fetchone ( ) 

# Ejemplo de uso 
sistema  =  SistemaGeolocalizacion ( ) 

# Buscar restaurantes cercanos a Madrid 
restaurantes  =  sistema . buscar_cercanos ( 
    lat = 40.416775 , 
    lon = - 3.703790 , 
    radio_km = 2 , 
    tipo = 'restaurante' 
) 

for  r  in  restaurantes : 
    print ( f" { r [ 'nombre' ] }  -  { r [ 'distancia_metros' ] : .0f } m" ) 

Casos de Uso de Bases Espaciales
pitÃ³n

"""
ğŸ“‹ APLICACIONES ESPECIALIZADAS:

1. Sistemas GIS
   â€¢ Mapas interactivos
   â€¢ PlanificaciÃ³n urbana
   â€¢ CartografÃ­a

2. LogÃ­stica y Transporte
   â€¢ OptimizaciÃ³n de rutas
   â€¢ Seguimiento de flotas
   â€¢ GestiÃ³n de almacenes

3. Real Estate
   â€¢ BÃºsqueda de propiedades
   â€¢ AnÃ¡lisis de mercados
   â€¢ ValoraciÃ³n de terrenos

4. Agricultura de PrecisiÃ³n
   â€¢ Monitoreo de cultivos
   â€¢ OptimizaciÃ³n de riego
   â€¢ AnÃ¡lisis de suelos

5. Telecomunicaciones
   â€¢ PlanificaciÃ³n de redes
   â€¢ AnÃ¡lisis de cobertura
   â€¢ UbicaciÃ³n de antenas
""" 

8. BASES DE DATOS DISTRIBUIDAS
CaracterÃ­sticas de Sistemas Distribuidos
pitÃ³n

"""
ğŸŒ BASES DISTRIBUIDAS:
â€¢ Datos replicados en mÃºltiples nodos
â€¢ Tolerancia a fallos
â€¢ Escalabilidad horizontal
â€¢ Consistencia eventual o fuerte

Ejemplos: Cassandra, CockroachDB, YugabyteDB, Google Spanner
""" 

Teorema CAP (Teorema de Brewer)
pitÃ³n

"""
ğŸ¯ TEOREMA CAP:
En sistemas distribuidos, solo puedes tener 2 de 3:

1. Consistencia (Consistency)
   â€¢ Todos los nodos ven los mismos datos al mismo tiempo

2. Disponibilidad (Availability)
   â€¢ El sistema responde siempre, incluso con fallos

3. Tolerancia a Particiones (Partition Tolerance)
   â€¢ El sistema funciona aunque se pierda comunicaciÃ³n entre nodos

Elecciones comunes:
â€¢ CP: Consistencia + Particiones (MongoDB, Redis)
â€¢ AP: Disponibilidad + Particiones (Cassandra, DynamoDB)
â€¢ CA: Consistencia + Disponibilidad (Bases relacionales tradicionales)
""" 

CockroachDB (compatible con PostgreSQL, distribuida)
SQL

-- CockroachDB: SQL distribuido 

-- Crear tabla distribuida 
CREATE  TABLE  transacciones_globales  ( 
    id UUID  PRIMARY  KEY  DEFAULT  gen_random_uuid ( ) , 
    usuario_id  INT , 
    monto  DECIMAL , 
    moneda  VARCHAR ( 3 ) , 
    fecha  TIMESTAMP  DEFAULT  now ( ) , 
    INDEX  idx_usuario  ( usuario_id ) 
) ; 

-- La tabla se distribuye automÃ¡ticamente 
-- CockroachDB decide la mejor distribuciÃ³n 

-- Consultas distribuidas funcionan como PostgreSQL 
SELECT  
    usuario_id , 
    COUNT ( * )  as  total_transacciones , 
    SUM ( monto )  as  volumen_total
 FROM  transacciones_globales
 WHERE  fecha  >=  '2024-01-01' 
GROUP  BY  usuario_id
 ORDER  BY  volumen_total  DESC 
LIMIT  10 ; 

-- Transacciones distribuidas 
BEGIN ; 

UPDATE  cuentas 
 SET  saldo  =  saldo  -  100  
WHERE  id  =  1  
AND  ubicacion  =  'nodo_usa' ; 

UPDATE  cuentas 
 SET  saldo  =  saldo  +  100  
WHERE  id  =  2  
AND  ubicacion  =  'nodo_europa' ; 

COMMIT ;   -- Commit atÃ³mico distribuido 

Cassandra (Distribuida, column-family)
pitÃ³n

de  cassandra  .  cluster  importar  Cluster
 de  cassandra  .  consulta  importar  SimpleStatement
 de  cassandra  .  polÃ­ticas  importar  DCAwareRoundRobinPolicy

 class   SistemaDistribuidoCassandra  : 
     def   __init__  (  self  ,  contact_points  )  : 
         # Conectar a cluster distribuido 
          mismo.clÃºster yo â€‹  =  ClÃºster  ( 
            puntos de contacto  , 
            polÃ­tica_de_equilibrio_de_carga  =  DCAwareRoundRobinPolicy  (  local_dc  =  'DC1'  ) 
         ) 
        ser  .  sesiÃ³n  =  yo  .  grupo  .  connect  (  ) 
        
         # Crear espacio de claves con replicaciÃ³n 
        self.sesion.exe â€‹ â€‹  (  "  "  " 
            CREAR ESPACIO DE LLAVES SI NO EXISTE sistema_distribuido
            CON replicaciÃ³n = {
                'clase': 'Estrategia de topologÃ­a de red',
                'DC1': 3,
                'DC2': 2
            }
        """  ) 
        
        ser  .  sesiÃ³n  .  set_keyspace  (  'sistema_distribuido'  ) 
    
     def   crear_tabla_distribuida  (  self  )  : 
         """Crear tabla con particionamiento y clustering""" 
        self.sesion.exe â€‹ â€‹  (  "  "  " 
            CREAR TABLA SI NO EXISTE metricas_globales (
                texto de la regiÃ³n,
                fecha marca de tiempo,
                texto del nombre_mÃ©trico,
                valor_mÃ©trico doble,
                etiquetas map<texto, texto>,
                CLAVE PRINCIPAL ((regiÃ³n, fecha), nombre_mÃ©trico)
            ) CON ORDEN DE AGRUPAMIENTO POR (nombre_mÃ©trico ASC)
        """ ) 
    
     def   escribir_metricas  (  self  ,  mÃ©tricas  )  : 
         """Escritura distribuida con consistencia configurable""" 
         from  cassandra  import  ConsistencyLevel
        
        insert_stmt  =  self.sesiÃ³n.preparar â€‹ â€‹  "  (  "  " 
            INSERTAR EN metricas_globales 
            (regiÃ³n, fecha, nombre_mÃ©trico, valor_mÃ©trico, etiquetas)
            VALORES (?, ?, ?, ?, ?)
        """  ) 
        
         # Configurar nivel de consistencia 
        sentencia_insertar  .  nivel_consistencia  =  NivelConsistencia  .  QUÃ“RUM
        
        lote  =   [  ] 
         para  mÃ©tricas  en  mÃ©tricas  : 
            lote.adjuntar â€‹ â€‹  (  ( 
                mÃ©trica  [  'regiÃ³n'  ]  , 
                mÃ©trica  [  'fecha'  ]  , 
                mÃ©trica  [  'nombre'  ]  , 
                mÃ©trica  [  'valor'  ]  , 
                metrica  .  get  (  'tags'  ,   {  }  ) 
             )  ) 
        
         # Ejecutar en paralelo 
         from  concurrent  .  futures  import  ThreadPoolExecutor
        
         def   insert_metric  (  parÃ¡metros  )  : 
            self  .  session  .  execute  (  insert_stmt  ,  params  ) 
        
         con  ThreadPoolExecutor  (  max_workers  =  10  )   como  ejecutor  : 
            ejecutor  .  map  (  insert_metric  ,  batch  ) 
    
     def   leer_metricas_distribuidas  (  self  ,  region ,  fecha_inicio ,  fecha_fin ) : 
        """Lectura desde mÃºltiples nodos""" 
        query  =  """
            SELECT 
                metric_name,
                AVG(metric_value) as avg_value,
                MAX(metric_value) as max_value,
                MIN(metric_value) as min_value
            FROM metricas_globales
            WHERE region = ?
            AND fecha >= ?
            AND fecha <= ?
            GROUP BY metric_name
        """ 
        
        prepared  =  self . session . prepare ( query ) 
        prepared . consistency_level  =  ConsistencyLevel . LOCAL_QUORUM
        
        rows  =  self . session . execute ( prepared ,  ( 
            region , 
            fecha_inicio , 
            fecha_fin
         ) ) 
        
        return  list ( rows ) 

# Uso del sistema distribuido 
sistema  =  SistemaDistribuidoCassandra ( [ 
    'node1.domain.com' , 
    'node2.domain.com' ,  
    'node3.domain.com' 
] ) 

# Datos de ejemplo 
metricas  =  [ 
    { 
        'region' :  'us-east' , 
        'fecha' :  '2024-01-15 10:00:00' , 
        'name' :  'cpu_usage' , 
        'value' :  75.5 , 
        'tags' :  { 'host' :  'server1' ,  'app' :  'web' } 
    } , 
    # ... mÃ¡s mÃ©tricas 
] 

sistema . escribir_metricas ( metricas ) 
resultados  =  sistema . leer_metricas_distribuidas ( 
    'us-east' , 
    '2024-01-15' , 
    '2024-01-16' 
) 

Patrones de DistribuciÃ³n
pitÃ³n

"""
ğŸ”§ PATRONES COMUNES:

1. Sharding (Particionamiento)
   â€¢ Dividir datos en fragmentos (shards)
   â€¢ Cada shard en nodo diferente
   â€¢ Ejemplo: MongoDB sharding

2. RÃ©plica Maestro-Esclavo
   â€¢ Un nodo maestro para escrituras
   â€¢ MÃºltiples esclavos para lecturas
   â€¢ Ejemplo: MySQL replication

3. RÃ©plica Multi-Maestro
   â€¢ MÃºltiples nodos aceptan escrituras
   â€¢ ResoluciÃ³n de conflictos necesaria
   â€¢ Ejemplo: Cassandra

4. Peer-to-Peer
   â€¢ Todos los nodos iguales
   â€¢ DistribuciÃ³n automÃ¡tica
   â€¢ Ejemplo: CockroachDB

5. FederaciÃ³n
   â€¢ MÃºltiples bases independientes
   â€¢ Vista unificada a travÃ©s de middleware
   â€¢ Ejemplo: PostgreSQL FDW
""" 

9. BASES DE DATOS MÃ“VILES Y EMBEBIDAS
SQLite (La mÃ¡s usada embebida)
pitÃ³n

"""
ğŸ“± SQLITE:
â€¢ Biblioteca en C, no servidor
â€¢ Base de datos en un solo archivo
â€¢ Zero-configuration
â€¢ Transaccionales ACID
â€¢ Usada en Android, iOS, navegadores, aplicaciones desktop
""" 

Ejemplo con Python SQLite:
pitÃ³n

importar  sqlite3
 importar  json
 desde  datetime  importar  datetime

 clase   AplicacionMovil  : 
     def   __init__  (  self  ,  db_path  =  'app.db'  )  : 
        self.conn â€‹ â€‹  =  sqlite3.connect â€‹ â€‹  (  ruta_de_base_de_datos  ,  comprobar_mismo_hilo  =  False  ) 
        self  .  conn  .  row_factory  =  sqlite3  .  Row
        ser  .  _inicializar_db  (  ) 
    
     def   _inicializar_db  (  self  )  : 
         """Crear tablas necesarias""" 
        cursor  =  yo  .  conexiÃ³n  .  cursor  (  ) 
        
         # Tabla de usuarios locales 
        cursor  .ejecutar  (  "  ""
            CREAR TABLA SI NO EXISTE usuarios (
                id ENTERO CLAVE PRIMARIA AUTOINCREMENTO,
                nombre de usuario TEXTO ÃšNICO NO NULO,
                correo electrÃ³nico TEXTO ÃšNICO,
                datos JSON,
                sincronizado BOOLEAN DEFAULT 0,
                fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """  ) 
        
         # Tabla de productos sin conexiÃ³n 
        cursor  .ejecutar  (  "  ""
            CREAR TABLA SI NO EXISTE productos (
                id ENTERO CLAVE PRIMARIA,
                nombre TEXTO NO NULO,
                precio REAL,
                stock ENTERO,
                categorÃ­a TEXTO,
                imagen_url TEXTO,
                ultima_actualizacion MARCA DE TIEMPO
            )
        """ ) 
        
        # Tabla para sincronizaciÃ³n 
        cursor . execute ( """
            CREATE TABLE IF NOT EXISTS sincronizaciones (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                tabla TEXT NOT NULL,
                accion TEXT NOT NULL,  -- INSERT, UPDATE, DELETE
                datos JSON NOT NULL,
                sincronizado BOOLEAN DEFAULT 0,
                fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """ ) 
        
        self . conn . commit ( ) 
    
    def  operacion_offline ( self ,  producto_id ,  cantidad ) : 
        """OperaciÃ³n que funciona sin conexiÃ³n""" 
        try : 
            cursor  =  self . conn . cursor ( ) 
            
            # Verificar stock local 
            cursor . execute ( 
                "SELECT stock FROM productos WHERE id = ?" , 
                ( producto_id , ) 
            ) 
            resultado  =  cursor . fetchone ( ) 
            
            if  not  resultado  or  resultado [ 'stock' ]  <  cantidad : 
                return  { 
                    'success' :  False , 
                    'error' :  'Stock insuficiente' 
                } 
            
            # Actualizar stock local 
            cursor . execute ( 
                "UPDATE productos SET stock = stock - ? WHERE id = ?" , 
                ( cantidad ,  producto_id ) 
            ) 
            
            # Registrar para sincronizaciÃ³n 
            cursor . execute ( """
                INSERT INTO sincronizaciones (tabla, accion, datos)
                VALUES (?, ?, ?)
            """ ,  ( 
                'ventas' , 
                'INSERT' , 
                json . dumps ( { 
                    'producto_id' :  producto_id , 
                    'cantidad' :  cantidad , 
                    'fecha' :  datetime . now ( ) . isoformat ( ) 
                } ) 
            ) ) 
            
            self . conn . commit ( ) 
            
            return  { 
                'success' :  True , 
                'message' :  'Venta registrada offline' 
            } 
            
        except  Exception  as  e : 
            self . conn . rollback ( ) 
            return  { 
                'success' :  False , 
                'error' :  str ( e ) 
            } 
    
    def  sincronizar_con_servidor ( self ) : 
        """Sincronizar cambios pendientes""" 
        import  requests
        
        cursor  =  self . conn . cursor ( ) 
        
        # Obtener cambios pendientes 
        cursor . execute ( """
            SELECT * FROM sincronizaciones 
            WHERE sincronizado = 0
            ORDER BY fecha
        """ ) 
        
        cambios  =  cursor . fetchall ( ) 
        
        for  cambio  in  cambios : 
            try : 
                # Enviar al servidor 
                response  =  requests . post ( 
                    'https://api.ejemplo.com/sync' , 
                    json = { 
                        'tabla' :  cambio [ 'tabla' ] , 
                        'accion' :  cambio [ 'accion' ] , 
                        'datos' :  json . loads ( cambio [ 'datos' ] ) 
                    } , 
                    timeout = 10 
                ) 
                
                if  response . status_code  ==  200 : 
                    # Marcar como sincronizado 
                    cursor . execute ( 
                        "UPDATE sincronizaciones SET sincronizado = 1 WHERE id = ?" , 
                        ( cambio [ 'id' ] , ) 
                    ) 
                else : 
                    print ( f"Error sincronizando cambio  { cambio [ 'id' ] } " ) 
                    
            except  Exception  as  e : 
                print ( f"Error de conexiÃ³n:  { e } " ) 
                break 
        
        self . conn . commit ( ) 
        
        # Sincronizar datos del servidor 
        self . _descargar_actualizaciones ( ) 
    
    def  _descargar_actualizaciones ( self ) : 
        """Descargar actualizaciones del servidor""" 
        import  requests
        
         try : 
            response  =  requests . get ( 
                'https://api.ejemplo.com/actualizaciones' , 
                params = { 'ultima_sincronizacion' :  self . _obtener_ultima_sincronizacion ( ) } , 
                timeout = 10 
            ) 
            
            if  response . status_code  ==  200 : 
                actualizaciones  =  response . json ( ) 
                
                cursor  =  self . conn . cursor ( ) 
                
                for  actualizacion  in  actualizaciones : 
                    if  actualizacion [ 'accion' ]  ==  'DELETE' : 
                        cursor . execute ( 
                            f"DELETE FROM  { actualizacion [ 'tabla' ] }  WHERE id = ?" , 
                            ( actualizacion [ 'id' ] , ) 
                        ) 
                    else : 
                        # UPSERT 
                        placeholders  =  ', ' . join ( [ '?'  for  _  in  actualizacion [ 'datos' ] ] ) 
                        columns  =  ', ' . join ( actualizacion [ 'datos' ] . keys ( ) ) 
                        values  =  list ( actualizacion [ 'datos' ] . values ( ) ) 
                        
                        query  =  f"""
                            INSERT OR REPLACE INTO  { actualizacion [ 'tabla' ] }  ( { columns } )
                            VALUES ( { placeholders } )
                        """ 
                        
                        cursor . execute ( query ,  values ) 
                
                self . conn . commit ( ) 
                
        except  Exception  as  e : 
            print ( f"Error descargando actualizaciones:  { e } " ) 

# Uso en aplicaciÃ³n mÃ³vil 
app  =  AplicacionMovil ( ) 

# OperaciÃ³n offline 
resultado  =  app . operacion_offline ( producto_id = 1 ,  cantidad = 2 ) 
print ( resultado ) 

# Cuando hay conexiÃ³n 
app . sincronizar_con_servidor ( ) 

Realm (Base de datos mÃ³vil orientada a objetos)
rÃ¡pido

// Realm en Swift (iOS) 
import  RealmSwift 

// Definir modelo 
class  Producto :  Object  { 
    @Persisted ( primaryKey :  true )  var  id :  ObjectId 
    @Persisted  var  nombre :  String 
    @Persisted  var  precio :  Double 
    @Persisted  var  stock :  Int 
    @Persisted  var  fechaActualizacion :  Date 
} 

// Uso 
let  realm  =  try !  Realm ( ) 

// Escribir 
try !  realm . write  { 
    let  producto  =  Producto ( ) 
    producto . nombre  =  "Laptop" 
    producto . precio  =  999.99 
    producto . stock  =  10 
    realm . add ( producto ) 
} 

// Leer 
let  productos  =  realm . objects ( Producto . self ) 
    . filter ( "stock > 0" ) 
    . sorted ( byKeyPath :  "precio" ) 

// SincronizaciÃ³n con Realm Sync 
let  app  =  App ( id :  "tu-app-id" ) 
let  user  =  try  await  app . login ( credentials :  . anonymous ) 
let  config  =  user . flexibleSyncConfiguration ( ) 
let  realm  =  try  await  Realm ( configuration :  config ) 

Firebase Firestore (Base de datos en la nube para mÃ³viles)
JavaScript

 Firestore en JavaScript 
 initializeApp   }  from  '   firebase   /app'  ; 
 import   {  getFirestore  ,  collection  ,  addDoc  ,  query  ,  where  ,  onSnapshot  }   from   'firebase/firestore'  ; 

 // Configurar Firebase 
 const  app  =   initializeApp  (  firebaseConfig  )  ; 
 const  db  =   getFirestore  (  app  )  ; 

 // Escribir datos 
 async   function   agregarProducto  (  producto  )   { 
     try   { 
         const  docRef  =   await   addDoc  (  collection  (  db  ,   "  )  ,   { 
             nombre  :  producto.nombre  (  fecha  , 
             precio  :  producto.precio  "  ,  ) 
             stock  :  producto.stock  ,  }  ) 
             Date  :   new   productos  ; // 
         Firebase  import  { 
        consola  .  log  (  "Documento escrito con ID: "  ,  docRef  .  id  )  ; 
     }   atrapar   (  e  )   { 
        consola  .  error  (  "Error al agregar documento: "  ,  e  )  ; 
     } 
 } 

 // Escuchar cambios en tiempo real 
 const  q  =   query  (  colecciÃ³n  (  db  ,   "productos"  )  ,   donde  (  "stock"  ,   ">"  ,   0  )  )  ; 
 const  darse de baja  =   onSnapshot  (  q  ,   (  instantÃ¡nea  )   =>   { 
    instantÃ¡nea  .docChanges â€‹  (  )  .forEach  "  (  (  cambio  )   =   { 
         if   (  cambio.type  >  "  ===   agregado  )   { 
            console.log  ( â€‹  (  Producto  ,  change.doc.data  { â€‹  ;  "  ===  )  )  } 
         if 
         (   change.type  )  nuevo  "  "   modified  "   : 
            console.log  ( â€‹  (  :  ,  change.doc.data â€‹  change.type  "  }  ===  )  )  ; 
         if 
         (   "  "  "  eliminado  Producto   modificado )  { 
            console . log ( "Producto eliminado: " ,  change . doc . data ( ) ) ; 
        } 
    } ) ; 
} ) ; 

// Offline persistence habilitado por defecto 

10. CÃ“MO ELEGIR LA BASE DE DATOS CORRECTA
Matriz de DecisiÃ³n
pitÃ³n

"""
ğŸ¯ MATRIZ DE SELECCIÃ“N:

Considera estos factores:

1. Volumen de Datos
   â€¢ PequeÃ±o (< 1GB): SQLite, PostgreSQL
   â€¢ Mediano (1GB-1TB): PostgreSQL, MySQL
   â€¢ Grande (> 1TB): Cassandra, BigQuery, distribuidas

2. Estructura de Datos
   â€¢ Altamente estructurado: Relacional
   â€¢ Semi-estructurado: Documental
   â€¢ No estructurado: Clave-valor
   â€¢ Relacional complejo: GrÃ¡fica
   â€¢ Temporal: Series de tiempo

3. PatrÃ³n de Acceso
   â€¢ MayorÃ­a lecturas: Cualquiera, optimizar Ã­ndices
   â€¢ MayorÃ­a escrituras: Cassandra, Kafka
   â€¢ Lecturas complejas: Relacional, GrÃ¡fica
   â€¢ Escrituras rÃ¡pidas: Clave-valor, en memoria

4. Consistencia Requerida
   â€¢ Fuerte (ACID): Relacional, algunos NoSQL
   â€¢ Eventual (BASE): NoSQL, distribuidas
   â€¢ CompensaciÃ³n: SAGA pattern, compensaciÃ³n

5. Escalabilidad
   â€¢ Vertical: Relacional tradicional
   â€¢ Horizontal: NoSQL, distribuidas
   â€¢ Elastic: Cloud databases

6. Presupuesto
   â€¢ Open source: PostgreSQL, MySQL, MongoDB
   â€¢ Commercial: Oracle, SQL Server, Enterprise DB
   â€¢ Cloud managed: RDS, CosmosDB, Firestore
""" 

Preguntas Clave para Decidir
pitÃ³n

"""
â“ PREGUNTAS PARA ELEGIR:

1. Â¿CuÃ¡l es el volumen de datos esperado?
2. Â¿QuÃ© estructura tienen los datos?
3. Â¿CuÃ¡l es el patrÃ³n de acceso (lectura/escritura)?
4. Â¿QuÃ© nivel de consistencia necesitas?
5. Â¿Necesitas transacciones ACID?
6. Â¿QuÃ© latencia es aceptable?
7. Â¿CÃ³mo escalarÃ¡ el sistema?
8. Â¿QuÃ© presupuesto tienes?
9. Â¿QuÃ© habilidades tiene tu equipo?
10. Â¿Necesitas soporte en la nube?
""" 

Ejemplos PrÃ¡cticos de ElecciÃ³n
pitÃ³n

"""
ğŸ“‹ CASOS REALES:

1. Sistema Bancario
   â€¢ Necesidad: ACID, consistencia fuerte
   â€¢ ElecciÃ³n: PostgreSQL, Oracle
   â€¢ RazÃ³n: Transacciones financieras requieren ACID

2. Red Social
   â€¢ Necesidad: Escalabilidad, relaciones complejas
   â€¢ ElecciÃ³n: Neo4j (grafos) + Cassandra (escala)
   â€¢ RazÃ³n: Relaciones sociales complejas, gran escala

3. IoT - Sensores
   â€¢ Necesidad: Series temporales, alta escritura
   â€¢ ElecciÃ³n: TimescaleDB, InfluxDB
   â€¢ RazÃ³n: Optimizado para datos temporales

4. Carrito de Compras
   â€¢ Necesidad: Sesiones temporales, alta concurrencia
   â€¢ ElecciÃ³n: Redis + PostgreSQL
   â€¢ RazÃ³n: Redis para sesiones, PostgreSQL para Ã³rdenes

5. CatÃ¡logo de Productos
   â€¢ Necesidad: BÃºsqueda flexible, schema variable
   â€¢ ElecciÃ³n: MongoDB, Elasticsearch
   â€¢ RazÃ³n: Datos semi-estructurados, bÃºsqueda poderosa

6. Sistema de Recomendaciones
   â€¢ Necesidad: AnÃ¡lisis de relaciones
   â€¢ ElecciÃ³n: Neo4j, Amazon Neptune
   â€¢ RazÃ³n: Relaciones complejas entre productos/usuarios

7. Analytics en Tiempo Real
   â€¢ Necesidad: Procesamiento stream, baja latencia
   â€¢ ElecciÃ³n: Apache Druid, ClickHouse
   â€¢ RazÃ³n: Optimizado para agregaciones en tiempo real

8. AplicaciÃ³n MÃ³vil
   â€¢ Necesidad: Offline-first, sincronizaciÃ³n
   â€¢ ElecciÃ³n: SQLite, Realm, Firebase
   â€¢ RazÃ³n: Funciona offline, sincroniza cuando hay conexiÃ³n
""" 

Arquitecturas hÃ­bridas (persistencia polÃ­glota)
pitÃ³n

"""
ğŸ—ï¸ ARQUITECTURAS HÃBRIDAS:

Muchas aplicaciones modernas usan mÃºltiples bases de datos:

Ejemplo: Plataforma de E-commerce

1. PostgreSQL
   â€¢ Usuarios
   â€¢ Ã“rdenes
   â€¢ Inventario
   â€¢ Pagos

2. Redis
   â€¢ Cache de sesiones
   â€¢ Carritos de compra
   â€¢ Contadores de visitas
   â€¢ Leaderboards

3. Elasticsearch
   â€¢ BÃºsqueda de productos
   â€¢ Logs de aplicaciÃ³n
   â€¢ Analytics

4. MongoDB
   â€¢ Contenido de productos
   â€¢ ReseÃ±as de usuarios
   â€¢ CatÃ¡logos flexibles

5. Neo4j
   â€¢ Sistema de recomendaciones
   â€¢ AnÃ¡lisis de relaciones

6. TimescaleDB
   â€¢ MÃ©tricas de rendimiento
   â€¢ AnÃ¡lisis temporal de ventas

Ventajas:
â€¢ Usar la mejor herramienta para cada tarea
â€¢ Mejor rendimiento especÃ­fico
â€¢ MÃ¡s flexibilidad

DesafÃ­os:
â€¢ Mayor complejidad
â€¢ MÃºltiples tecnologÃ­as para aprender
â€¢ SincronizaciÃ³n entre sistemas
â€¢ Mantenimiento mÃ¡s complejo
""" 

Tendencias Actuales
pitÃ³n

"""
ğŸš€ TENDENCIAS 2024:

1. Bases de Datos Multi-Modelo
   â€¢ Una base que soporte mÃºltiples modelos
   â€¢ Ejemplo: PostgreSQL (relacional + JSON + grafos)
   â€¢ Ejemplo: ArangoDB (documentos + grafos + clave-valor)

2. Serverless Databases
   â€¢ Auto-escalado automÃ¡tico
   â€¢ Pago por uso
   â€¢ Sin administraciÃ³n de servidores
   â€¢ Ejemplo: Amazon Aurora Serverless, Firebase

3. Bases de Datos en la Nube
   â€¢ Managed services
   â€¢ Escalabilidad automÃ¡tica
   â€¢ Alta disponibilidad incorporada
   â€¢ Ejemplo: Google Cloud Spanner, Azure Cosmos DB

4. Bases de Datos para Machine Learning
   â€¢ IntegraciÃ³n con ML/AI
   â€¢ Vector databases para embeddings
   â€¢ Ejemplo: Pinecone, Weaviate, pgvector

5. Bases de Datos de BÃºsqueda Especializadas
   â€¢ Optimizadas para full-text search
   â€¢ BÃºsqueda semÃ¡ntica
   â€¢ Ejemplo: Elasticsearch, Algolia, Typesense

6. Bases de Datos de Bloques (Blockchain)
   â€¢ Inmutabilidad
   â€¢ DescentralizaciÃ³n
   â€¢ Transparencia
   â€¢ Ejemplo: BigchainDB, Ethereum
""" 

CONCLUSIÃ“N
Resumen de Tipos Principales
pitÃ³n

"""
ğŸ“Š RESUMEN FINAL:

1. Relacionales (SQL)
   â€¢ Para: Datos estructurados, ACID, consultas complejas
   â€¢ Ejemplo: PostgreSQL, MySQL

2. Documentales (NoSQL)
   â€¢ Para: Datos semi-estructurados, schema flexible
   â€¢ Ejemplo: MongoDB, CouchDB

3. Clave-Valor (NoSQL)
   â€¢ Para: Cache, sesiones, datos simples
   â€¢ Ejemplo: Redis, DynamoDB

4. Column-Family (NoSQL)
   â€¢ Para: Big data, anÃ¡lisis, alta escritura
   â€¢ Ejemplo: Cassandra, HBase

5. GrÃ¡ficas (NoSQL)
   â€¢ Para: Relaciones complejas, redes sociales
   â€¢ Ejemplo: Neo4j, Amazon Neptune

6. Series de Tiempo
   â€¢ Para: Datos temporales, IoT, mÃ©tricas
   â€¢ Ejemplo: InfluxDB, TimescaleDB

7. En Memoria
   â€¢ Para: Baja latencia, cache, tiempo real
   â€¢ Ejemplo: Redis, Memcached

8. Distribuidas
   â€¢ Para: Escalabilidad global, alta disponibilidad
   â€¢ Ejemplo: CockroachDB, YugabyteDB

9. MÃ³viles/Embebidas
   â€¢ Para: Aplicaciones offline, dispositivos
   â€¢ Ejemplo: SQLite, Realm

10. Espaciales
    â€¢ Para: Datos geogrÃ¡ficos, mapas, GIS
    â€¢ Ejemplo: PostGIS, SpatiaLite
""" 

RecomendaciÃ³n Final
pitÃ³n

"""
ğŸ¯ MI RECOMENDACIÃ“N:

Para la mayorÃ­a de proyectos:

1. Comienza con PostgreSQL
   â€¢ Es versÃ¡til y potente
   â€¢ Soporta JSON, arrays, bÃºsqueda full-text
   â€¢ Tiene extensiones para casi todo
   â€¢ Comunidad excelente

2. Agrega Redis para cache y datos temporales
   â€¢ Mejora rendimiento dramÃ¡ticamente
   â€¢ Simple de implementar
   â€¢ Muy maduro

3. Considera bases especializadas segÃºn necesidades
   â€¢ Grafos: Neo4j para relaciones complejas
   â€¢ BÃºsqueda: Elasticsearch para full-text
   â€¢ Series de tiempo: TimescaleDB para mÃ©tricas
   â€¢ MÃ³vil: SQLite/Realm para apps offline

4. EvalÃºa necesidades de escala
   â€¢ Si necesitas escala masiva: Cassandra, ScyllaDB
   â€¢ Si necesitas distribuciÃ³n global: CockroachDB
   â€¢ Si necesitas serverless: Cloud managed services

Recuerda: La mejor base de datos es la que resuelve
tu problema especÃ­fico de manera efectiva y mantenible.
""" 

Â¿Te gustarÃ­a profundizar en algÃºn tipo especÃ­fico de base de datos o en cÃ³mo implementar arquitecturas hÃ­bridas? Â¡Estoy aquÃ­ para ayudarte! ğŸš€ 