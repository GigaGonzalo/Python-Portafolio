üîÑ UPDATE: Actualizaci√≥n de Datos en PostgreSQL

El comando UPDATE es fundamental para modificar datos existentes en tus tablas. Vamos a explorarlo en profundidad, desde lo b√°sico hasta t√©cnicas avanzadas.
√çNDICE

    Sintaxis B√°sica

    Condiciones WHERE

    Actualizaci√≥n M√∫ltiple

    ACTUALIZAR con UNIRSE

    UPDATE con Subconsultas

    ACTUALIZACI√ìN con REGRESO

    Uso de Triggers con UPDATE

    Buenas Pr√°cticas

    Ejemplos con Python 

1. SINTAXIS B√ÅSICA
Forma Est√°ndar
SQL

-- Sintaxis b√°sica 
UPDATE  nombre_tabla
 SET  
    columna1  =  valor1 , 
    columna2  =  valor2 , 
    . . . 
WHERE  condici√≥n ; 

-- Ejemplo concreto 
UPDATE  empleados
 SET  
    salario  =  50000 , 
    departamento  =  'Ventas' , 
    fecha_promocion  =  CURRENT_DATE 
WHERE  id  =  1 ; 

Actualizaci√≥n de Todas las Filas (¬°CUIDADO!)
SQL

-- Actualiza TODAS las filas de la tabla 
UPDATE  productos 
 SET  precio  =  precio  *  1.10 ;   -- Aumenta todos los precios 10% 

-- Siempre usa WHERE a menos que sea intencional 
UPDATE  configuracion 
 SET  tema  =  'oscuro' 
WHERE  usuario_id  =  1 ;   -- SOLO para usuario espec√≠fico 

Actualizaci√≥n con Expresiones
SQL

-- Usando operaciones matem√°ticas 
UPDATE  productos 
 SET  
    precio  =  precio  *  0.90 ,   -- 10% de descuento 
    stock  =  stock  -  5 
WHERE  categoria  =  'Liquidaci√≥n' ; 

-- Usando funciones 
UPDATE  usuarios 
 SET  
    password_hash  =  crypt ( 'nueva_password' ,  gen_salt ( 'bf' ) ) , 
    ultimo_cambio_password  =  CURRENT_TIMESTAMP 
WHERE  id  =  1 ; 

-- Concatenaci√≥n de strings 
UPDATE  clientes 
 SET  
    nombre_completo  =  nombre  ||  ' '  ||  apellido , 
    email  =  LOWER ( email ) 
WHERE  nombre_completo  IS  NULL ; 

2. CONDICIONES WHERE
Operadores B√°sicos
SQL

-- Igualdad 
UPDATE  productos  SET  activo  =  false  WHERE  id  =  100 ; 

-- Desigualdad 
UPDATE  empleados  SET  bono  =  1000  WHERE  salario  <  40000 ; 

-- BETWEEN 
UPDATE  pedidos  SET  estado  =  'completado'  
WHERE  fecha  BETWEEN  '2024-01-01'  AND  '2024-12-31' ; 

-- IN 
UPDATE  productos  SET  categoria  =  'Electr√≥nica'  
WHERE  id  IN  ( 1 ,  5 ,  10 ,  15 ) ; 

-- LIKE/ILIKE 
UPDATE  clientes  SET  region  =  'Norte'  
WHERE  ciudad  ILIKE  '%madrid%'  OR  ciudad  ILIKE  '%barcelona%' ; 

-- IS NULL / IS NOT NULL 
UPDATE  empleados  SET  bono  =  500  
WHERE  bono  IS  NULL  AND  salario  >  45000 ; 

Condiciones Complejas
SQL

-- M√∫ltiples condiciones con AND/OR 
UPDATE  inventario 
 SET  
    estado  =  'bajo_stock' , 
    fecha_alerta  =  CURRENT_DATE 
WHERE  
    ( stock  <  stock_minimo  AND  producto_id  IN  ( SELECT  id  FROM  productos  WHERE  activo  =  true ) ) 
    OR  ( ultima_reposicion  <  CURRENT_DATE  -  INTERVAL  '30 days' ) 
    OR  ( stock  =  0 ) ; 

-- Usando CASE en WHERE 
UPDATE  ventas 
 SET  comision  =  monto  *  0.15 
WHERE  
    CASE  
        WHEN  vendedor_experiencia  >  5  THEN  monto  >  10000 
        WHEN  vendedor_experiencia  BETWEEN  2  AND  5  THEN  monto  >  5000 
        ELSE  monto  >  1000 
    END ; 

3. ACTUALIZACI√ìN M√öLTIPLE
Actualizar M√∫ltiples Columnas
SQL

-- Actualizar varias columnas a la vez 
UPDATE  usuarios 
 SET  
    ultimo_login  =  CURRENT_TIMESTAMP , 
    contador_logins  =  contador_logins  +  1 , 
    ip_ultimo_login  =  '192.168.1.100' 
WHERE  username  =  'admin' ; 

-- Actualizar basado en otras columnas 
UPDATE  productos 
 SET  
    precio_con_iva  =  precio_sin_iva  *  1.21 , 
    margen_ganancia  =  ( precio_sin_iva  -  costo )  /  costo  *  100 , 
    rentable  =  CASE  WHEN  ( precio_sin_iva  -  costo )  >  0  THEN  true  ELSE  false  END 
WHERE  activo  =  true ; 

Actualizaci√≥n Condicional con CASE
SQL

-- Actualizaci√≥n condicional compleja 
UPDATE  empleados 
 SET  
    salario  =  CASE 
        WHEN  departamento  =  'Ventas'  AND  ventas_anuales  >  100000  THEN  salario  *  1.20 
        WHEN  departamento  =  'IT'  AND  experiencia  >  3  THEN  salario  *  1.15 
        WHEN  evaluacion  =  'Excelente'  THEN  salario  *  1.10 
        WHEN  evaluacion  =  'Buena'  THEN  salario  *  1.05 
        ELSE  salario  *  1.02   -- Aumento m√≠nimo 
    END , 
    nivel  =  CASE 
        WHEN  salario  >  80000  THEN  'Senior' 
        WHEN  salario  >  50000  THEN  'Mid' 
        ELSE  'Junior' 
    END 
WHERE  activo  =  true ; 

Actualizaci√≥n Masiva con L√≠mites
SQL

-- Actualizar en lotes (para evitar bloqueos largos) 
DO  $$
 DECLARE 
    batch_size  INT  : =  1000 ; 
    rows_updated  INT  : =  batch_size ; 
BEGIN 
    WHILE  rows_updated  =  batch_size  LOOP 
        UPDATE  pedidos 
         SET  estado  =  'procesado' 
        WHERE  estado  =  'pendiente' 
        AND  id  IN  ( 
            SELECT  id 
             FROM  pedidos 
             WHERE  estado  =  'pendiente' 
            ORDER  BY  fecha_pedido
             LIMIT  batch_size
             FOR  UPDATE  SKIP LOCKED   -- Evita deadlocks 
        ) ; 
        
        GET DIAGNOSTICS rows_updated  =  ROW_COUNT ; 
        COMMIT ;   -- Commit peri√≥dico 
        
        -- Peque√±a pausa para reducir carga 
        PERFORM pg_sleep ( 0.1 ) ; 
    END  LOOP ; 
END  $$ ; 

4. ACTUALIZAR CON UNIRSE
UNI√ìN INTERNA
SQL

-- Actualizar usando datos de otra tabla 
UPDATE  empleados e
 SET  
    salario  =  salario  *  d . factor_aumento , 
    departamento_id  =  d . id
 FROM  departamentos d
 WHERE  e . departamento_actual  =  d . nombre
 AND  d . ubicacion  =  'Madrid' ; 

-- Ejemplo pr√°ctico: actualizar precios basados en proveedor 
UPDATE  productos p
 SET  
    precio  =  p . precio  *  pr . factor_inflacion , 
    costo  =  p . costo  *  pr . factor_costo
 FROM  proveedores pr
 WHERE  p . proveedor_id  =  pr . id
 AND  pr . pais  =  'Espa√±a' 
AND  pr . calificacion  =  'A' ; 

LEFT JOIN (Para manejar NULLs)
SQL

-- Actualizar aunque no haya coincidencia 
 ACTUALIZAR  clientes c
 COLOCAR  
    segmento  =   COALESCE  (  s  .  nombre  ,   'Sin Segmento'  )  , 
    valor_del_cliente  =  c.compras_totales   compras_totales  *   COALESCE  (  s.multiplicador . )  ,   1 s 
 DE  segmentos_del_cliente 
  IZQUIERDA  UNI√ìN  clientes_segmentos  EN  c.id   id  =  cscs.client_id  cs 
 DONDE  cs  .  segment_id  =  s  .  id  O  cs  .  segment_id  ES   NULO  ; 

M√∫ltiples JOINs
SQL

-- Actualizaci√≥n compleja con m√∫ltiples relaciones 
UPDATE  pedidos p
 SET  
    prioridad  =  'Alta' , 
    fecha_entrega_estimada  =  p . fecha_pedido  +  INTERVAL  '2 days' 
FROM  clientes c
 JOIN  contratos ct  ON  c . id  =  ct . cliente_id
 JOIN  niveles_servicio ns  ON  ct . nivel_servicio_id  =  ns . id
 WHERE  p . cliente_id  =  c . id
 AND  p . estado  =  'pendiente' 
AND  ns . nombre  =  'Premium' 
AND  p . total  >  1000 
AND  c . antiguedad  >  INTERVAL  '1 year' ; 

Auto UNIRSE
SQL

-- Actualizar basado en datos de la misma tabla 
UPDATE  empleados e1
 SET  
    salario  =  e1 . salario  *  1.10 , 
    jefe_id  =  e2 . id
 FROM  empleados e2
 WHERE  e1 . departamento_id  =  e2 . departamento_id
 AND  e2 . cargo  =  'Director' 
AND  e1 . cargo  =  'Gerente' 
AND  e1 . salario  <  e2 . salario  *  0.5 ; 

5. UPDATE CON SUBCONSULTAS
Subconsulta escalar
SQL

-- Actualizar con valor calculado 
UPDATE  productos 
 SET  
    precio_promedio_mercado  =  ( 
        SELECT  AVG ( precio )  
        FROM  productos_competencia 
         WHERE  categoria  =  productos . categoria
     ) , 
    competitivo  =  CASE  
        WHEN  precio  <=  ( 
            SELECT  AVG ( precio )  *  0.9  
            FROM  productos_competencia 
             WHERE  categoria  =  productos . categoria
         )  THEN  true  
        ELSE  false  
    END 
WHERE  activo  =  true ; 

-- Actualizar con correlaci√≥n 
UPDATE  empleados e
 SET  
    salario_relativo  =  e . salario  /  ( 
        SELECT  AVG ( salario )  
        FROM  empleados 
         WHERE  departamento_id  =  e . departamento_id
     )  *  100 
WHERE  e . activo  =  true ; 

Subconsulta en WHERE
SQL

-- Actualizar empleados que superan el promedio 
UPDATE  empleados 
 SET  bono  =  5000 
WHERE  salario  >  ( 
    SELECT  AVG ( salario )  
    FROM  empleados 
     WHERE  departamento_id  =  empleados . departamento_id
 ) ; 

-- Actualizar productos sin ventas recientes 
UPDATE  productos 
 SET  
    activo  =  false , 
    fecha_desactivacion  =  CURRENT_DATE 
WHERE  id  NOT  IN  ( 
    SELECT  DISTINCT  producto_id 
     FROM  detalles_pedido dp
     JOIN  pedidos p  ON  dp . pedido_id  =  p . id
     WHERE  p . fecha  >  CURRENT_DATE  -  INTERVAL  '90 days' 
) ; 

Subconsulta relacionada
SQL

-- Actualizar el √∫ltimo pedido de cada cliente 
UPDATE  pedidos p
 SET  
    prioridad  =  'Alta' , 
    etiqueta  =  'Reciente' 
WHERE  p . id  =  ( 
    SELECT  id 
     FROM  pedidos 
     WHERE  cliente_id  =  p . cliente_id 
     ORDER  BY  fecha_pedido  DESC  
    LIMIT  1 
) ; 

-- Actualizar productos con stock bajo 
UPDATE  inventario i
 SET  
    estado  =  'necesita_reposicion' , 
    fecha_alerta  =  CURRENT_DATE 
WHERE  i . stock  <  ( 
    SELECT  AVG ( d . cantidad )  *  2 
    FROM  detalles_pedido d
     JOIN  pedidos p  ON  d . pedido_id  =  p . id
     WHERE  d . producto_id  =  i . producto_id
     AND  p . fecha  >  CURRENT_DATE  -  INTERVAL  '30 days' 
) ; 

CTE (Expresiones de tabla comunes)
SQL

-- UPDATE complejo con CTE 
WITH  ventas_por_empleado  AS  ( 
    SELECT  
        empleado_id , 
        SUM ( total )  as  ventas_totales , 
        COUNT ( * )  as  num_ventas
     FROM  ventas
     WHERE  fecha  >=  DATE_TRUNC ( 'month' ,  CURRENT_DATE ) 
    GROUP  BY  empleado_id
 ) , 
promedios  AS  ( 
    SELECT  
        AVG ( ventas_totales )  as  promedio_ventas , 
        AVG ( num_ventas )  as  promedio_num_ventas
     FROM  ventas_por_empleado
 ) 
UPDATE  empleados e
 SET  
    bono  =  CASE 
        WHEN  v . ventas_totales  >  p . promedio_ventas  *  1.5  THEN  3000 
        WHEN  v . ventas_totales  >  p . promedio_ventas  THEN  1500 
        ELSE  500 
    END , 
    desempenio  =  CASE 
        WHEN  v . ventas_totales  >  p . promedio_ventas  THEN  'Sobre el promedio' 
        ELSE  'Debajo del promedio' 
    END 
FROM  ventas_por_empleado v
 CROSS  JOIN  promedios p
 WHERE  e . id  =  v . empleado_id ; 

6. ACTUALIZACI√ìN CON REGRESO
Obtener Datos Actualizados
SQL

-- Obtener filas actualizadas 
UPDATE  productos 
 SET  precio  =  precio  *  1.10 
WHERE  categoria  =  'Electr√≥nica' 
RETURNING  id ,  nombre ,  precio  AS  nuevo_precio ; 

-- Usar en expresiones 
UPDATE  empleados 
 SET  
    salario  =  salario  *  1.05 , 
    fecha_aumento  =  CURRENT_DATE 
WHERE  departamento  =  'Ventas' 
RETURNING  
    id , 
    nombre , 
    salario  AS  salario_nuevo , 
    salario  /  1.05  AS  salario_anterior , 
    ( salario  /  1.05  *  0.05 )  AS  aumento_monto ; 

-- Con JOINs 
UPDATE  pedidos p
 SET  estado  =  'completado' 
FROM  clientes c
 WHERE  p . cliente_id  =  c . id
 AND  c . pais  =  'Espa√±a' 
AND  p . estado  =  'pendiente' 
RETURNING  
    p . id , 
    p . numero_pedido , 
    c . nombre  AS  cliente , 
    p . total ; 

-- Para auditor√≠a 
UPDATE  usuarios 
 SET  
    ultimo_login  =  CURRENT_TIMESTAMP , 
    contador_intentos  =  0 
WHERE  username  =  'admin' 
RETURNING  
    id , 
    username , 
    ultimo_login , 
    'Login exitoso'  AS  evento
 INTO  TEMP  auditoria_login ; 

Ejemplo Pr√°ctico con RETURNING
SQL

-- Sistema de inventario con auditor√≠a 
WITH  productos_actualizados  AS  ( 
    UPDATE  inventario 
     SET  
        stock  =  stock  -  1 , 
        ultima_salida  =  CURRENT_TIMESTAMP , 
        total_salidas  =  total_salidas  +  1 
    WHERE  producto_id  =  100 
    AND  stock  >  0 
    RETURNING  
        producto_id , 
        stock  AS  nuevo_stock , 
        ( SELECT  nombre  FROM  productos  WHERE  id  =  100 )  AS  producto_nombre
 ) 
INSERT  INTO  auditoria_inventario  ( 
    producto_id , 
    accion , 
    cantidad , 
    stock_despues , 
    fecha
 ) 
SELECT  
    producto_id , 
    'VENTA' , 
    1 , 
    nuevo_stock , 
    CURRENT_TIMESTAMP 
FROM  productos_actualizados
 RETURNING  id  AS  auditoria_id ; 

7. USO DE TRIGGERS CON UPDATE
Triggers para Auditor√≠a
SQL

-- Crear tabla de auditor√≠a 
CREATE  TABLE  auditoria_empleados  ( 
    id  SERIAL  PRIMARY  KEY , 
    empleado_id  INT  NOT  NULL , 
    campo_modificado  VARCHAR ( 50 ) , 
    valor_anterior  TEXT , 
    valor_nuevo  TEXT , 
    usuario_modificacion  VARCHAR ( 100 ) , 
    fecha_modificacion  TIMESTAMP  DEFAULT  CURRENT_TIMESTAMP 
) ; 

-- Funci√≥n del trigger 
CREATE  OR  REPLACE  FUNCTION  auditar_cambios_empleados ( ) 
RETURNS  TRIGGER  AS  $$
 BEGIN 
    IF  OLD . salario  !=  NEW . salario  THEN 
        INSERT  INTO  auditoria_empleados  ( 
            empleado_id , 
            campo_modificado , 
            valor_anterior , 
            valor_nuevo , 
            usuario_modificacion
         )  VALUES  ( 
            OLD . id , 
            'salario' , 
            OLD . salario:: TEXT , 
            NEW . salario:: TEXT , 
            CURRENT_USER 
        ) ; 
    END  IF ; 
    
    IF  OLD . departamento_id  !=  NEW . departamento_id  THEN 
        INSERT  INTO  auditoria_empleados  ( 
            empleado_id , 
            campo_modificado , 
            valor_anterior , 
            valor_nuevo , 
            usuario_modificacion
         )  VALUES  ( 
            OLD . id , 
            'departamento_id' , 
            OLD . departamento_id:: TEXT , 
            NEW . departamento_id:: TEXT , 
            CURRENT_USER 
        ) ; 
    END  IF ; 
    
    RETURN  NEW ; 
END ; 
$$  LANGUAGE  plpgsql ; 

-- Crear trigger 
CREATE  TRIGGER  trigger_auditar_empleados
BEFORE  UPDATE  ON  empleados
 FOR EACH ROW 
EXECUTE  FUNCTION  auditar_cambios_empleados ( ) ; 

Trigger para Validaci√≥n
SQL

-- Validar que el salario no disminuya 
CREATE  OR  REPLACE  FUNCTION  validar_aumento_salario ( ) 
RETURNS  TRIGGER  AS  $$
 BEGIN 
    IF  NEW . salario  <  OLD . salario  THEN 
        RAISE EXCEPTION  'El salario no puede disminuir. Actual: %, Nuevo: %' ,  
            OLD . salario ,  NEW . salario ; 
    END  IF ; 
    
    -- Validar aumento m√°ximo del 20% 
    IF  NEW . salario  >  OLD . salario  *  1.20  THEN 
        RAISE EXCEPTION  'El aumento no puede superar el 20%%' ; 
    END  IF ; 
    
    RETURN  NEW ; 
END ; 
$$  LANGUAGE  plpgsql ; 

CREATE  TRIGGER  trigger_validar_salario
BEFORE  UPDATE  ON  empleados
 FOR EACH ROW 
EXECUTE  FUNCTION  validar_aumento_salario ( ) ; 

Trigger para Mantener Hist√≥rico
SQL

-- Tabla hist√≥rica 
CREATE  TABLE  productos_historico  ( 
    id  SERIAL  PRIMARY  KEY , 
    producto_id  INT  NOT  NULL , 
    precio_anterior  DECIMAL ( 10 , 2 ) , 
    precio_nuevo  DECIMAL ( 10 , 2 ) , 
    usuario_cambio  VARCHAR ( 100 ) , 
    fecha_cambio  TIMESTAMP  DEFAULT  CURRENT_TIMESTAMP 
) ; 

-- Trigger para hist√≥rico de precios 
CREATE  OR  REPLACE  FUNCTION  guardar_historico_precios ( ) 
RETURNS  TRIGGER  AS  $$
 BEGIN 
    IF  OLD . precio  !=  NEW . precio  THEN 
        INSERT  INTO  productos_historico  ( 
            producto_id , 
            precio_anterior , 
            precio_nuevo , 
            usuario_cambio
         )  VALUES  ( 
            OLD . id , 
            OLD . precio , 
            NEW . precio , 
            CURRENT_USER 
        ) ; 
    END  IF ; 
    
    RETURN  NEW ; 
END ; 
$$  LANGUAGE  plpgsql ; 

CREATE  TRIGGER  trigger_historico_precios
 AFTER  UPDATE  ON  productos
 FOR EACH ROW 
EXECUTE  FUNCTION  guardar_historico_precios ( ) ; 

8. BUENAS PR√ÅCTICAS
Seguridad y Validaci√≥n
SQL

-- ‚ùå PELIGROSO: Sin WHERE (actualiza todo) 
UPDATE  usuarios  SET  activo  =  true ; 

-- ‚úÖ SEGURO: Siempre con WHERE 
UPDATE  usuarios  SET  activo  =  true  WHERE  id  =  1 ; 

-- ‚ùå PELIGROSO: SQL Injection vulnerable 
UPDATE  productos  SET  precio  =  100  WHERE  nombre  =  '$nombre' ; 

-- ‚úÖ SEGURO: Usar par√°metros 
-- En Python: cursor.execute("UPDATE productos SET precio = %s WHERE nombre = %s", (100, nombre)) 

-- ‚úÖ Validar antes de actualizar 
BEGIN ; 
-- Verificar existencia primero 
SELECT  id  FROM  productos  WHERE  id  =  100  FOR  UPDATE ; 

-- Luego actualizar 
UPDATE  productos  SET  precio  =  150  WHERE  id  =  100 ; 
COMMIT ; 

Rendimiento
SQL

-- ‚ùå INEFICIENTE: Actualizaci√≥n fila por fila en bucle 
FOR  id  IN  ( SELECT  id  FROM  productos  WHERE  stock  <  10 )  LOOP 
    UPDATE  productos  SET  necesita_reposicion  =  true  WHERE  id  =  id ; 
END  LOOP ; 

-- ‚úÖ EFICIENTE: Actualizaci√≥n masiva 
UPDATE  productos 
 SET  necesita_reposicion  =  true  
WHERE  stock  <  10 ; 

-- ‚ùå LENTO: Sin √≠ndice en columna WHERE 
UPDATE  ventas  SET  procesado  =  true  WHERE  fecha  =  '2024-01-15' ; 
-- Necesita: CREATE INDEX idx_ventas_fecha ON ventas(fecha); 

-- ‚úÖ R√ÅPIDO: Con √≠ndice apropiado 
UPDATE  ventas  SET  procesado  =  true  
WHERE  id  IN  ( 
    SELECT  id  FROM  ventas 
     WHERE  fecha  =  '2024-01-15' 
    LIMIT  1000 
) ; 

Concurrencia y Bloqueos
SQL

-- ‚ùå PROBLEMA: Bloqueo prolongado de tabla 
UPDATE  productos  SET  precio  =  precio  *  1.10 ; 
-- Bloquea TODA la tabla durante la operaci√≥n 

-- ‚úÖ SOLUCI√ìN: Actualizar en lotes 
DO  $$
 DECLARE 
    batch_size  INT  : =  1000 ; 
    last_id  INT  : =  0 ; 
    rows_updated  INT ; 
BEGIN 
    LOOP 
        UPDATE  productos 
         SET  precio  =  precio  *  1.10 
        WHERE  id  >  last_id
         AND  id  <=  last_id  +  batch_size ; 
        
        GET DIAGNOSTICS rows_updated  =  ROW_COUNT ; 
        EXIT  WHEN  rows_updated  =  0 ; 
        
        last_id : =  last_id  +  batch_size ; 
        COMMIT ;   -- Liberar bloqueos peri√≥dicamente 
    END  LOOP ; 
END  $$ ; 

-- ‚úÖ USAR: FOR UPDATE SKIP LOCKED para evitar deadlocks 
UPDATE  pedidos 
 SET  estado  =  'procesando' 
WHERE  id  IN  ( 
    SELECT  id 
     FROM  pedidos 
     WHERE  estado  =  'pendiente' 
    ORDER  BY  prioridad  DESC ,  fecha_pedido
     LIMIT  100 
    FOR  UPDATE  SKIP LOCKED
 ) ; 

Mantenibilidad
SQL

-- ‚ùå CONFUSO: Actualizaci√≥n compleja en una l√≠nea 
UPDATE  t  SET  a = b , b = c , c = a  WHERE  x = y  AND  ( z > 5  OR  z < 0 )  AND  NOT  w  IS  NULL ; 

-- ‚úÖ CLARO: Separar y comentar 
UPDATE  productos 
 SET  
    -- Aplicar descuento del 15% 
    precio  =  precio  *  0.85 , 
    -- Marcar como en oferta 
    en_oferta  =  true , 
    -- Actualizar fecha de cambio de precio 
    fecha_ultimo_cambio_precio  =  CURRENT_DATE 
WHERE  
    -- Solo productos de estas categor√≠as 
    categoria  IN  ( 'Electr√≥nica' ,  'Hogar' ) 
    -- Con stock disponible 
    AND  stock  >  0 
    -- Que no est√©n ya en oferta 
    AND  en_oferta  =  false 
    -- Y tengan m√°s de 3 meses sin cambios 
    AND  ( fecha_ultimo_cambio_precio  IS  NULL  
         OR  fecha_ultimo_cambio_precio  <  CURRENT_DATE  -  INTERVAL  '3 months' ) ; 

9. EJEMPLOS CON PYTHON
Clase Base para Actualizaci√≥n de Datos
pit√≥n

importar  psycopg2
 desde  psycopg2  importar  sql
 de  psycopg2  .  extras  importar  execute_batch
 desde  escribir  importar  Lista  ,  Diccionario  ,  Cualquiera  ,  Opcional  ,  Tupla
  de importaci√≥n registro 

 clase   PostgreSQLUpdater  : 
     def   __init__  (  self  ,  par√°metros_de_conexi√≥n  )  : 
        self  .  par√°metros_de_conexi√≥n  =  par√°metros_de_conexi√≥n
        self  .  conn  =   Ninguno 
        self.logger  __  logging.getLogger  =  "  def  (  name__  self  ) 
    
     (   connect  )  try  "  : 
         """Establecer conexi√≥n 
         :  " 
            self.conn ‚Äã ‚Äã  =  psycopg2.connect ‚Äã ‚Äã  (  **  self.par√°metros_de_conexi√≥n ‚Äã ‚Äã  ) 
            ser  .  registrador  .  info  (  "Conexi√≥n establecida"  ) 
             return  self  .  conectar
         excepto  Excepci√≥n  como  e  : 
            ser  .  registrador  .  error  (  f"Error de conexi√≥n:  {  e  }  "  ) 
             plantear 
    
     def   desconectar  (  self  )  : 
         """Cerrar conexi√≥n""" 
         if  self  .  conexi√≥n  : 
            auto  .  conexi√≥n  .  cerrar  (  ) 
            self  .  logger  .  info  (  "Conexi√≥n cerrada"  ) 
    
     def   update_single  (  self  ,  table  :   str  ,  data  :  Dict  ,  condition  :  Dict  )   -  >   int  : 
         """Actualizar un solo registro""" 
         if   not  self  .  conn  : 
            self.connect ‚Äã ‚Äã  (  ) 
        
         try  : 
             con  self.conn.cursor ‚Äã ‚Äã  SET  cursor  (  )   como  Construir  : 
                 # 
                cl√°usulas_conjunto  =   [  ] 
                establecer_valores  =  [  ] 
                 para  clave  ,  valor  en  datos.items ‚Äã ‚Äã  (  )  : 
                    set_clauses  .append  (  "  f"  {  clave  }  = %s  ) 
                    set_values  ‚Äã‚Äã.  append  (  valor  ) 
                
                 # Construir WHERE 
                donde_cl√°usulas  =   [  ] 
                where_values  ‚Äã‚Äã=   [  ] 
                 para  clave  ,  valor  en  condici√≥n.items ‚Äã ‚Äã  (  )  : 
                    cl√°usulas_donde  .append  "  (  f"  {  clave  }  = %s  ) 
                    donde_valores  .  append  (  valor  ) 
                
                 # Construir consulta completa 
                consulta  =  sql  .  SQL  (  """
                    ACTUALIZAR {tabla}
                    SET {cl√°usula_establecida}
                    D√ìNDE {cl√°usula_donde}
                """  )  .  formato  ( 
                    tabla  =  sql  .  Identificador  (  tabla  )  , 
                    set_clause  =  sql  .  SQL  (  ', '  )  .  join  (  [  sql  .  SQL  (  cl√°usula  )   para  cl√°usula  en  set_clauses  ]  )  , 
                    where_clause  =  sql  .  SQL  (  ' AND '  )  .  join  (  [  sql  .  SQL  (  clause  )   for  clause  in  where_clauses  ]  ) 
                 ) 
                
                 # Ejecutar con todos los valores 
                todos_valores  =  establecer_valores  +  donde_valores
                cursor  .execute ‚Äã  (  consulta  ,  todos_valores  ) 
                
                filas_afectadas  =  cursor .  recuento de filas
                auto  .  conexi√≥n  .  confirmaci√≥n  (  ) 
                
                self.logger.info  "  :  (  Filas  }  f  {  rows_affected  "  )  actualizadas 
                 return  rows_affected
                
         excepto  Excepci√≥n  como  e  : 
            auto  .  conexi√≥n  .  reversi√≥n  (  ) 
            ser  .  registrador  .  error  (  f"Error al actualizar:  {  e  }  "  ) 
             rise 
    
     def   update_batch  (  self  ,  table  :   str  ,  actualizaciones  :  List  [  Tuple  [  Dict  ,  Dict  ]  ]  )   -  >   int  : 
         """Actualizar m√∫ltiples registros con diferentes condiciones""" 
         if   not  self  .  conexi√≥n  : 
            yo  .  conectar  (  ) 
        
        total_updated  =   0 
        
         try  : 
             with  self  .  conn  .  cursor  (  )   as  cursor  : 
                 for  data  ,  condition  in  updates  : 
                     # Similar a update_single pero en batch 
                    set_clauses  =   [  f"  {  k  }  = %s"   para  k  en  datos  .  keys  (  )  ] 
                    donde_cl√°usulas  =   [  f"  {  k  }  = %s"   para  k  en  condici√≥n  .  keys  (  )  ] 
                    
                    consulta  =   f"""
                        ACTUALIZAR  {  tabla  } 
                        SET  {  ', '  .  join  (  set_clauses  )  } 
                        DONDE  {  ' Y '  .  unir  (  cl√°usulas_donde  )  } 
                    """ 
                    
                    valores =   lista  (  datos.valores ‚Äã ‚Äã  (  )  )   +   lista  (  condiciones.valores ‚Äã ‚Äã  (  )  ) 
                    cursor  .execute ‚Äã  (  consulta  ,  valores  ) 
                    total_actualizado  +=  cursor  .  recuento_de_filas
                
                auto  .  conexi√≥n  .  confirmaci√≥n  (  ) 
                ser  .  registrador  .  info  (  f"Total filas actualizadas en lote:  {  total_updated  }  "  ) 
                 return  total_updated
                
         excepto  Excepci√≥n  como  e  : 
            auto  .  conexi√≥n  .  reversi√≥n  (  ) 
            self  .  logger  .  error  (  f"Error en actualizaci√≥n batch:  {  e  }  "  ) 
             raise 
    
     def   update_with_join  (  self  ,  update_query  :   str  ,  params  :  Tuple  =   None  )   -  >   int  : 
         """Ejecutar UPDATE complejo con JOINs""" 
         if   not  self  .  conn  : 
            self.connect ‚Äã ‚Äã  (  ) 
        
         intenta  : 
             con  self.conn.cursor ‚Äã ‚Äã ‚Äã  cursor  (  )   como ‚Äã  : 
                cursor  .execute ‚Äã  (  update_query  ,  params  o   (  )  ) 
                filas_afectadas  =  cursor  .  rowcount
                auto  .  conexi√≥n  .  confirmaci√≥n  (  ) 
                
                self  .  logger  .  info  (  f"UPDATE con JOIN - Filas afectadas:  {  rows_affected  }  "  ) 
                 return  rows_affected
                
         excepto  Excepci√≥n  como  e  : 
            auto  .  conexi√≥n  .  reversi√≥n  (  ) 
            ser .  logger  .  error  (  f"Error en UPDATE con JOIN:  {  e  }  "  ) 
             raise 
    
     def   update_and_return  (  self  ,  table  :   str  ,  data  :  Dict  ,  condition  :  Dict  )   -  >  List  [  Dict  ]  : 
         """UPDATE con RETURNING para obtener datos actualizados""" 
         if   not  self  .  conn  : 
            self.connect ‚Äã ‚Äã  (  ) 
        
         try  : 
             con  self.conn.cursor ‚Äã ‚Äã  SET  cursor  (  )   como  Construir  : 
                 # 
                cl√°usulas_conjunto  =   [  ] 
                set_values  ‚Äã‚Äã=   [  ] 
                 para  clave  ,  valor  en  datos.items ‚Äã ‚Äã  (  )  : 
                    set_clauses  .append  (  "  f"  {  clave  }  = %s  ) 
                    set_values  ‚Äã‚Äã.  append  (  valor  ) 
                
                 # Construir WHERE 
                donde_cl√°usulas  =   [  ] 
                where_values  ‚Äã‚Äã=   [  ] 
                 para  clave  ,  valor  en  condici√≥n.items ‚Äã ‚Äã  (  )  : 
                    cl√°usulas_donde  .append  "  (  f"  {  clave  }  = %s  ) 
                    where_values  ‚Äã‚Äã.  append  (  valor  ) 
                
                 # Construir consulta con RETURNING 
                consulta  =  sql  .  SQL  (  """
                    ACTUALIZAR {tabla}
                    SET {cl√°usula_establecida}
                    D√ìNDE {cl√°usula_donde}
                    REGRESO *
                """  )  .  formato  ( 
                    tabla  =  sql  .  Identificador  (  tabla  )  , 
                    cl√°usula_de_establecimiento =  sql  .  SQL  (  ', '  )  .  join  (  [  sql  .  SQL  (  cl√°usula  )   para  cl√°usula  en  set_clauses  ]  )  , 
                    cl√°usula_donde  =  sql  .  SQL  (  ' AND '  )  .  join  (  [  sql  .  SQL  (  cl√°usula  )   for  cl√°usula  in  cl√°usulas_donde  ]  ) 
                 ) 
                
                 # Ejecutar 
                todos_valores  =  establecer_valores  +  donde_valores
                cursor  .  ejecutar  (  consulta  ,  todos_valores  ) 
                
                 # Obtener resultados 
                column_names  =   [  desc  [  0  ]   para  desc  en  cursor  .  descripci√≥n  ] 
                resultados  =   [ 
                     dict  (  zip  (  nombres_de_columna  ,  fila  )  ) 
                     para  fila  en  cursor.fetchall  el  )  (  ] 
                 la 
                
                auto  .  conexi√≥n  .  confirmaci√≥n  (  ) 
                self  .  logger  .  info  (  f"ACTUALIZAR con RETORNANDO -  {  len  (  resultados  )  }  filas retornadas"  ) 
                 devolver  resultados
                
         excepto  Excepci√≥n  como  e  : 
            auto  .  conexi√≥n  .  reversi√≥n  (  ) 
            ser  .  registrador  .  error  (  f"Error en UPDATE con RETURNING:  {  e  }  "  ) 
             rise 
    
     def   safe_update  (  self  ,  table  :   str  ,  data  :  Dict  ,  condition  :  Dict  )   -  >  Dict  : 
         """UPDATE seguro con validaciones y manejo de errores""" 
         if   not  self  .  conexi√≥n  : 
            ser  .  conectar  (  ) 
        
         intentar  : 
             con  uno mismo  .  conexi√≥n  .  cursor  (  )   as  cursor  : 
                 # 1. Verificar que existen registros que cumplen la condici√≥n 
                check_query  =   f"SELECCIONAR CONTAR(*) DE  {  tabla  }  DONDE " 
                check_query  +=   " AND "  .  join  (  [  f"  {  k  }  = %s"   para  k  en  la condici√≥n  .  keys  (  )  ]  ) 
                
                cursor  .execute ‚Äã  (  check_query  ,   list  (  condition.values  ( ‚Äã ‚Äã  )  )  ) 
                cuenta  =  cursor  .  fetchone  (  )  [  0  ] 
                
                 if  count  ==   0  : 
                     return   { 
                         'success'  :   False  , 
                         'message'  :   'No se encontraron registros para actualizar'  , 
                         'rows_affected'  :   0 
                     } 
                
                 # 2. Ejecutar UPDATE 
                set_clauses  =   [  f"  {  k  }  = %s"   para  k  en  datos  .  keys  (  )  ] 
                donde_cl√°usulas  =   [  f"  {  k  }  = %s"   para  k  en  condici√≥n  .  keys  (  )  ] 
                
                consulta_de_actualizaci√≥n  =   f"""
                    ACTUALIZAR  {  tabla  } 
                    SET  {  ', '  .  join  (  set_clauses  )  } 
                    DONDE  {  ' Y '  .  unir  (  cl√°usulas_donde  )  } 
                """ 
                
                all_values  ‚Äã‚Äã=   lista  (  datos.valores ‚Äã ‚Äã  (  )  )   +   lista  (  condiciones.valores ‚Äã ‚Äã  (  )  ) 
                cursor  .execute ‚Äã  (  actualizar_consulta  ,  todos_valores  ) 
                
                filas_afectadas  =  cursor  .  rowcount
                auto  .  conexi√≥n  .  compromiso (  ) 
                
                 devolver   { 
                     '√©xito'  :   Verdadero  , 
                     'mensaje'  :   actualizados  f'Registros {  rows_affected  }  '  , 
                     'rows_affected'  :  filas_affectadas
                 } 
                
         excepto  psycopg2.IntegrityError   IntegrityError  como  e : 
            self  .  conn  .  rollback  (  ) 
             return   { 
                 'success'  :   False  , 
                 'message'  :   'Error de integridad de datos'  , 
                 'error'  :   str  (  e  )  , 
                 'rows_affected'  :   0 
             } 
         except  Exception  as  e  : 
            self.conn.rollback  :  ,  __name__  (  )  : 
             return   { 
                 'success'  False   ,  ' 
                 message'  '   Error al actualizar'  ' 
                 error'  :   str  (  e  )  , 
                 'rows_affected'  0   } 
             # 

 Ejemplo de uso 
 if  :  ==   "__main__"  : 
     # Configuraci√≥n 
    config  =   { 
         'dbname'  :   'empresa_db'  , 
         'user'  :   'admin'  , 
         'senha'  :   'senha'  , 
         'host'  :   'localhost' 
     } 
    
     # Configurar el registro 
    logging.basicConfig   basicConfig (  nivel  =  log.INFO .INFO) 
    
    actualizador  =  PostgreSQLUpdater  (  config  ) 
    actualizador  .  connect  (  ) 
    
     # 1. Actualizar un empleado 
    filas  =  actualizador  .  update_single  ( 
        tabla  =  'empleados'  , 
        data  =  { 
             'salario'  :   55000  , 
             'departamento'  :   'Ventas Senior'  , 
             'fecha_promocion'  :   '2024-01-20' 
         }  , 
        condici√≥n  =  {  'id'  :   1  } 
     ) 
     print  (  f"Empleado actualizado:  {  filas  }  fila(s)"  ) 
    
     # 2. Actualizar lote 
    actualizaciones =  [ 
        ( 
            { 'precio' :  19.99 ,  'en_oferta' :  True } , 
            { 'id' :  10 ,  'categoria' :  'Electr√≥nica' } 
        ) , 
        ( 
            { 'precio' :  29.99 ,  'en_oferta' :  True } , 
            { 'id' :  11 ,  'categoria' :  'Electr√≥nica' } 
        ) , 
        ( 
            { 'stock' :  0 ,  'activo' :  False } , 
            { 'id' :  15 ,  'stock' :  1 } 
        ) 
    ] 
    
    total  =  updater . update_batch ( 'productos' ,  updates ) 
    print ( f"Total actualizado en batch:  { total } " ) 
    
    # 3. UPDATE con JOIN complejo 
    join_query  =  """
        UPDATE pedidos p
        SET 
            estado = 'completado',
            fecha_completado = CURRENT_TIMESTAMP
        FROM clientes c
        WHERE p.cliente_id = c.id
        AND c.pais = 'Espa√±a'
        AND p.estado = 'pendiente'
        AND p.fecha_pedido < CURRENT_DATE - INTERVAL '7 days'
    """ 
    
    rows_join  =  updater . update_with_join ( join_query ) 
    print ( f"Pedidos completados:  { rows_join } " ) 
    
    # 4. UPDATE con RETURNING 
    resultados  =  updater . update_and_return ( 
        table = 'usuarios' , 
        data = { 
            'ultimo_login' :  '2024-01-20 10:30:00' , 
            'contador_logins' :  'contador_logins + 1' 
        } , 
        condition = { 'id' :  1 } 
    ) 
    print ( f"Datos actualizados:  { resultados } " ) 
    
    # 5. UPDATE seguro 
    resultado_seguro  =  updater . safe_update ( 
        table = 'productos' , 
        data = { 'precio' :  99.99 } , 
        condition = { 'id' :  999 }   # ID que no existe 
    ) 
    print ( f"Resultado seguro:  { resultado_seguro } " ) 
    
    updater . disconnect ( ) 

Ejemplo Avanzado: Sistema de Inventario
pit√≥n

clase   InventoryManager  : 
     def   __init__  (  self  ,  db_config  )  : 
          mismo.db_config yo ‚Äã  =  db_config 
        self  .  conn  =   None 
    
     def   update_stock_after_sale  (  self  ,  product_id  :   int  ,  amount  :   int  )   -  >  Dict  : 
         """Actualizar stock despu√©s de una venta""" 
         try  : 
            self.conn ‚Äã ‚Äã  =  psycopg2.connect ‚Äã ‚Äã  (  **  self.db_config ‚Äã ‚Äã  ) 
            ser  .  conexi√≥n  .  autocommit  =   False 
            
             con  self  .  conexi√≥n  .  cursor  (  )   as  cursor  : 
                 # Bloquear el registro para evitar condiciones de carrera 
                cursor  .ejecutar  (  "  ""
                    SELECCIONAR stock, stock_minimo 
                    DE productos 
                    DONDE id = %s PARA ACTUALIZAR
                """  ,   (  id_del_producto  ,  )  ) 
                
                result  =  cursor  .  fetchone  (  ) 
                 if   not  result  : 
                     raise  ValueError  (  f"Producto  {  product_id  }  no encontrado"  ) 
                
                stock_actual  ,  stock_m√≠n  =  resultado
                
                 # Verificar stock suficiente 
                 if  current_stock  <  amount  : 
                     raise  ValueError  (  f"Stock insuficiente. Disponible:  {  current_stock  }  "  ) 
                
                 # Actualizar stock 
                nuevo_stock =  current_stock  -  quantity
                cursor . execute ( """
                    UPDATE productos 
                    SET 
                        stock = %s,
                        fecha_ultima_salida = CURRENT_TIMESTAMP,
                        total_vendido = total_vendido + %s
                    WHERE id = %s
                    RETURNING id, nombre, stock
                """ ,  ( new_stock ,  quantity ,  product_id ) ) 
                
                updated_product  =  cursor . fetchone ( ) 
                
                # Registrar en historial 
                cursor . execute ( """
                    INSERT INTO historial_stock (
                        producto_id,
                        tipo_movimiento,
                        cantidad,
                        stock_despues,
                        motivo
                    ) VALUES (%s, %s, %s, %s, %s)
                """ ,  ( product_id ,  'VENTA' ,  - quantity ,  new_stock ,  'Venta normal' ) ) 
                
                # Verificar si necesita reposici√≥n 
                if  new_stock  <  min_stock : 
                    cursor . execute (  """
                        INSERTAR EN alertas_reposicion (
                            producto_id,
                            stock_actual,
                            stock_minimo,
                            fecha_alerta
                        ) VALORES (%s, %s, %s, MARCA_DE_TIEMPO_ACTUAL)
                        EN CONFLICTO (producto_id) ACTUALIZAR CONJUNTO
                            fecha_alerta = CURRENT_TIMESTAMP
                    """  ,   (  id_producto  ,  nuevo_stock  ,  stock_m√≠n  )  ) 
                
                self.conn.commit  :  [  1  2  (  ) 
                
                 return   { 
                     success'  :   True  , 
                     'product_id'  :  updated_product  0  ,  ]  , 
                     'product_name'  updated_product  [  ]  new_stock  '  ' 
                     '  updated_product  [  :  ]  ,  ' 
                     message'  :   actualizado correctamente' 
                 } 
                
         except  Exception  as  e  : 
             if  self.conn  Stock  :  ' 
                self.conn.rollback  '  self.conn  :  (  (  ) 
             return   { 
                 success'  False   ,  ' 
                 error'  :   str  )  e  '  , 
                 'message'  :   al actualizar 
             } 
         finally  : 
             if  '  :  Error  stock 
                ser  .  conexi√≥n  .  close  (  ) 
    
     def   Bulk_price_update  (  self  ,  actualizaciones  :  Lista  [  Dict  ]  ,  porcentaje  :   float  )   -  >  Dict  : 
         """Actualizaci√≥n masiva de precios""" 
        intentar  : 
            ser  .  conexi√≥n  =  psicopg2  .  connect  (  **  self.db_config  para  self  ) 
            
             # Usar transacci√≥n 
             con  consistencia  .  conexi√≥n  .  cursor  (  )   como  cursor  : 
                 # Crear tabla temporal 
                cursor  .ejecutar  (  "  ""
                    CREAR TABLA TEMPORAL temp_price_updates (
                        product_id INT CLAVE PRINCIPAL,
                        nuevo_precio DECIMAL(10,2)
                    ) AL COMPROBAR Y SOLTAR
                """  ) 
                
                 # Insertar datos temporales 
                insert_data  =   [  (  u  [  'id'  ]  ,  u  [  'current_price'  ]   *   (  1   +  porcentaje  /  100  )  )  
                               para  u  en  actualizaciones  ] 
                
                ejecutar_lote  (  cursor  ,   """
                    INSERTAR EN temp_price_updates (id_producto, nuevo_precio)
                    VALORES (%s, %s)
                    EN CONFLICTO (product_id) ACTUALIZAR CONJUNTO
                        nuevo_precio = EXCLUIDO.nuevo_precio
                """  ,  insert_data  ) 
                
                 # Actualizar productos usando JOIN 
                cursor  .ejecutar  (  "  ""
                    CON AS actualizado (
                        ACTUALIZACI√ìN productos p
                        COLOCAR 
                            precio = t.nuevo_precio,
                            fecha_ultimo_cambio_precio = CURRENT_TIMESTAMP
                        DESDE actualizaciones_de_precios_temp
                        DONDE p.id = t.product_id
                        DEVOLVIENDO p.id, p.nombre, p.precio como old_price, t.new_price
                    )
                    INSERTAR EN precios_historico (
                        producto_id,
                        precio_anterior,
                        precio_nuevo,
                        porcentaje_cambio,
                        usuario
                    )
                    SELECCIONAR 
                        identificaci√≥n,
                        precio_antiguo,
                        nuevo_precio,
                        ((precio_nuevo - precio_anterior) / precio_anterior * 100),
                        USUARIO ACTUAL
                    DESDE actualizado
                """ ) 
                
                filas_afectadas  =  cursor  .  rowcount
                self.conn.commit  f'Precios  self.conn  :  {  (  ) 
                
                 return   { 
                     'success'  True   ,  ' 
                     rows_updated'  ,  '  message 
                     :  actualizados   :  rows_affected  }  productos  ' 
                 } 
                
         except  Exception  as  e  : 
             if  rows_affected  :  :  ' 
                self.conn.rollback  )  :  :  (  )  ' 
             return   { 
                 √©xito  :   Falso  , 
                 error  :   str  (  e  '  , 
                 filas_actualizadas  '   0 
             } 
         finalmente  ' 
             si  self.conn  :  '  ' 
                ser  .  conexi√≥n  .  close  (  ) 

 # Uso del sistema de inventario 
 if  __name__  ==   "__main__"  : 
    db_config  =   { 
         'dbname'  :   'inventario_db'  , 
         'usuario'  :   'admin'  , 
         'contrase√±a'  :   'contrase√±a'  , 
         'host'  :   'localhost' 
     } 
    
    manager  =  InventoryManager  (  db_config  ) 
    
     # Actualizar stock despu√©s de la venta 
    resultado  =  manager  .actualizar_stock_postventa ‚Äã  ( 
        id_del_producto  =  1  , 
        cantidad  =  2 
     ) 
     print  (  f"Resultado venta:  {  resultado  }  "  ) 
    
     # Actualizaci√≥n masiva de precios 
    productos_a_actualizar  =   [ 
         {  'id'  :   1  ,   'precio_actual'  :   100  }  , 
         {  'id'  :   2  ,   'precio_actual'  :   50  }  , 
         {  'id'  :   3  ,   'precio_actual'  :   75  } 
     ] 
    
    resultado_actualizar  =  manager.update_precio_masivo ‚Äã  ( ‚Äã 
        actualizaciones  =  productos_a_actualizar  , 
        porcentaje = 10   # Aumento del 10% 
    ) 
    print ( f"Resultado actualizaci√≥n precios:  { update_result } " ) 

Sistema de Actualizaci√≥n con Reintentos
pit√≥n

 de importaci√≥n tiempo 
 desde  escribir  importar  Callable

 clase   RetryUpdateManager  : 
     def   __init__  (  self  ,  db_config  ,  max_retries  =  3  ,  retry_delay  =  1  )  : 
          mismo.db_config yo ‚Äã  =  db_config 
        self  .max_retries ‚Äã  =  max_retries 
        self.retry_delay ‚Äã ‚Äã  =  retraso_de_retry 
    
     def   execute_with_retry  (  self  ,  update_func  :  Callable  ,   *  args  ,   **  kwargs  )   -  >  Dict  : 
         "Ejecutar UPDATE con reintentos en caso de interbloqueo""" 
         range  (  self.max_retries   )  :  try  and  for  :  return 
             update_func  ( 
                 *  args  ,  **  kwargs  )   except  psycopg2.OperationalError  as 
                
             e  :  in  )  if  '  interbloqueo 
                 '   str   (   e  .lower  (  attempt  )  {  <  attempt   :  self.max_retries  -  1  in  "  (   print  f 
                     "  Interbloqueo  (Intento  )  attempt  +   1  }  /  {  self.max_retries  }  )  reintentando ...  detectado  , 
                    tiempo  .  dormir  (  self  .  retry_delay  *   (  intento  +   1  )  )    # Retroceso exponencial 
                     continuar 
                 else  : 
                     rise 
    
     def   concurrent_update_example  (  self  ,  product_id  :   int  )   -  >  Dict  : 
         """Ejemplo de actualizaci√≥n concurrente segura""" 
         def   update_product  (  )  : 
            conn  =  psycopg2  .  connect  (  **  self  .  db_config  ) 
             try  : 
                 with  conn  .  cursor  (  )   as  cursor  : 
                     # Usar NOWAIT para evitar bloqueos largos 
                    cursor .  ejecutar  (  """
                        SELECCIONAR * DE productos 
                        DONDE id = %s PARA ACTUALIZAR AHORA ESPERA
                    """  ,   (  product_id  ,  )  ) 
                    
                     # Actualizar con verificaci√≥n de versi√≥n 
                    cursor  .ejecutar  (  "  ""
                        ACTUALIZAR productos 
                        COLOCAR 
                            stock = stock - 1,
                            versi√≥n = versi√≥n + 1,
                            ultima_actualizacion = CURRENT_TIMESTAMP
                        DONDE id = %s Y versi√≥n = %s
                        DEVOLUCI√ìN de stock, versi√≥n
                    """  ,   (  product_id  ,  kwargs  .  get  (  'current_version'  ,   0  )  )  ) 
                    
                     if  cursor  .  rowcount  ==   0  : 
                         rise  Exception  (  "El registro fue modificado por otro proceso"  ) 
                    
                    resultado  =  cursor  .  fetchone  (  ) 
                    conn.commit  )  [  (  ' 
                    
                     return   { 
                         success'  :   True  , 
                         'new_stock'  :  resultado  ]  0  '  , 
                         new_version'  :  resultado  [  1  ] 
                     } 
                    
             finally  : 
                conn.close ‚Äã  (  )  ) 
        
         return  self.execute_with_retry  con  Uso  (  update_product  # 

 reintentos 
si  __nombre__  ==   "__principal__"  : 
    db_config  =   { 
         'dbname'  :   'concurrent_db'  , 
         'usuario'  :   'admin'  , 
         'contrase√±a'  :   'contrase√±a'  , 
         'host'  :   'localhost' 
     } 
    
    retry_manager  =  RetryUpdateManager  (  db_config  ) 
    
     intentar  : 
        resultado  =  retry_manager  .  concurrent_update_example  (  product_id  =  1  ) 
         print  (  f"Actualizaci√≥n exitosa:  {  result  }  "  ) 
     excepto  Excepci√≥n  como  e  : 
         print  (  f"Error despu√©s de reintentos:  {  e  }  "  ) 

EJERCICIOS PR√ÅCTICOS
Nivel B√°sico:

    Aumentar salarios un 5% a todos los empleados de un departamento

    Actualizar estado de pedidos pendientes a "completado"

    Corregir emails poni√©ndolos en min√∫sculas 

Nivel Intermedio:

    Actualizar precios basados en inflaci√≥n usando JOIN con proveedores

    Recalcular comisiones usando subconsultas y CASE

    Sincronizar datos entre tablas relacionadas 

Nivel Avanzado:

    Implementar optimistic locking con columnas de versi√≥n

    Batch update con control de concurrencia usando SKIP LOCKED

    Sistema de historial que guarda cambios autom√°ticamente con triggers 

CONSEJOS FINALES
Para M√°ximo Rendimiento:

    Usa √≠ndices en columnas del WHERE

    Actualiza en lotes grandes, no fila por fila

    Evita actualizar columnas indexadas innecesariamente

    Usa EXPLAIN ANALYZE para analizar el plan de ejecuci√≥n 

Para Seguridad:

    Siempre usa WHERE espec√≠fico

    Usa transacciones para operaciones at√≥micas

    Implementa validaciones en la aplicaci√≥n y en la base de datos

    Mant√©n backups antes de actualizaciones masivas 

Para Concurrencia:

    Usa FOR UPDATE cuando necesites exclusividad

    NOWAIT o SKIP LOCKED para evitar bloqueos.

    Implementa optimistic locking con columnas de versi√≥n

    Maneja deadlocks con reintentos exponenciales 

Para Mantenibilidad:

    Documenta updates complejos con comentarios

    Usa RETURNING para verificar cambios

    Implementa auditor√≠a de cambios importantes

    Prueba en staging antes de producci√≥n 

¬øTe gustar√≠a profundizar en alg√∫n aspecto espec√≠fico de UPDATE? Por ejemplo:

    Optimizaci√≥n de UPDATEs masivos (millones de registros)

    Sistemas de versionado y historial completo

    Replicaci√≥n y sincronizaci√≥n entre bases de datos

    UPDATE con datos JSON/JSONB avanzados 

¬°Continuemos fortaleciendo tus habilidades en PostgreSQL! üöÄ 